"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SalesLoft Platform
 * SalesLoft helps transform sales teams into modern sales organizations  - converting more target accounts into customer accounts
 *
 * OpenAPI spec version: v2
 * Contact: integrations@salesloft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://api.salesloft.com".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * AccountStagesApi - fetch parameter creator
 * @export
 */
exports.AccountStagesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches an account stage, by ID only.
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnAccountStage.');
            }
            var localVarPath = "/v2/account_stages/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/account_stages.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountStagesApi - functional programming interface
 * @export
 */
exports.AccountStagesApiFp = function (configuration) {
    return {
        /**
         * Fetches an account stage, by ID only.
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage: function (id, options) {
            var localVarFetchArgs = exports.AccountStagesApiFetchParamCreator(configuration).fetchAnAccountStage(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.AccountStagesApiFetchParamCreator(configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccountStagesApi - factory interface
 * @export
 */
exports.AccountStagesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches an account stage, by ID only.
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage: function (id, options) {
            return exports.AccountStagesApiFp(configuration).fetchAnAccountStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.AccountStagesApiFp(configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * AccountStagesApi - object-oriented interface
 * @export
 * @class AccountStagesApi
 * @extends {BaseAPI}
 */
var AccountStagesApi = /** @class */ (function (_super) {
    __extends(AccountStagesApi, _super);
    function AccountStagesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches an account stage, by ID only.
     * @summary Fetch an account stage
     * @param {string} id Account Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStagesApi
     */
    AccountStagesApi.prototype.fetchAnAccountStage = function (id, options) {
        return exports.AccountStagesApiFp(this.configuration).fetchAnAccountStage(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List account stages
     * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStagesApi
     */
    AccountStagesApi.prototype.listAccountStages = function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.AccountStagesApiFp(this.configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return AccountStagesApi;
}(BaseAPI));
exports.AccountStagesApi = AccountStagesApi;
/**
 * AccountTiersApi - fetch parameter creator
 * @export
 */
exports.AccountTiersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches an account tier, by ID only.
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnAccountTier.');
            }
            var localVarPath = "/v2/account_tiers/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers: function (ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/account_tiers.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (name) {
                localVarQueryParameter['name'] = name.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountTiersApi - functional programming interface
 * @export
 */
exports.AccountTiersApiFp = function (configuration) {
    return {
        /**
         * Fetches an account tier, by ID only.
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier: function (id, options) {
            var localVarFetchArgs = exports.AccountTiersApiFetchParamCreator(configuration).fetchAnAccountTier(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers: function (ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.AccountTiersApiFetchParamCreator(configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccountTiersApi - factory interface
 * @export
 */
exports.AccountTiersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches an account tier, by ID only.
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier: function (id, options) {
            return exports.AccountTiersApiFp(configuration).fetchAnAccountTier(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers: function (ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.AccountTiersApiFp(configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * AccountTiersApi - object-oriented interface
 * @export
 * @class AccountTiersApi
 * @extends {BaseAPI}
 */
var AccountTiersApi = /** @class */ (function (_super) {
    __extends(AccountTiersApi, _super);
    function AccountTiersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches an account tier, by ID only.
     * @summary Fetch an account tier
     * @param {string} id Account Tier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTiersApi
     */
    AccountTiersApi.prototype.fetchAnAccountTier = function (id, options) {
        return exports.AccountTiersApiFp(this.configuration).fetchAnAccountTier(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List Account Tiers
     * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTiersApi
     */
    AccountTiersApi.prototype.listAccountTiers = function (ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.AccountTiersApiFp(this.configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return AccountTiersApi;
}(BaseAPI));
exports.AccountTiersApi = AccountTiersApi;
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
exports.AccountsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team.
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount: function (name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling createAnAccount.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain', 'Required parameter domain was null or undefined when calling createAnAccount.');
            }
            var localVarPath = "/v2/accounts.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (domain !== undefined) {
                localVarFormParams.set('domain', domain);
            }
            if (conversationalName !== undefined) {
                localVarFormParams.set('conversational_name', conversationalName);
            }
            if (description !== undefined) {
                localVarFormParams.set('description', description);
            }
            if (phone !== undefined) {
                localVarFormParams.set('phone', phone);
            }
            if (website !== undefined) {
                localVarFormParams.set('website', website);
            }
            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl);
            }
            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle);
            }
            if (street !== undefined) {
                localVarFormParams.set('street', street);
            }
            if (city !== undefined) {
                localVarFormParams.set('city', city);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (postalCode !== undefined) {
                localVarFormParams.set('postal_code', postalCode);
            }
            if (country !== undefined) {
                localVarFormParams.set('country', country);
            }
            if (locale !== undefined) {
                localVarFormParams.set('locale', locale);
            }
            if (industry !== undefined) {
                localVarFormParams.set('industry', industry);
            }
            if (companyType !== undefined) {
                localVarFormParams.set('company_type', companyType);
            }
            if (founded !== undefined) {
                localVarFormParams.set('founded', founded);
            }
            if (revenueRange !== undefined) {
                localVarFormParams.set('revenue_range', revenueRange);
            }
            if (size !== undefined) {
                localVarFormParams.set('size', size);
            }
            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact);
            }
            if (customFields) {
                localVarFormParams.set('custom_fields', customFields.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (tags) {
                localVarFormParams.set('tags', tags.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId);
            }
            if (companyStageId !== undefined) {
                localVarFormParams.set('company_stage_id', companyStageId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account.
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteAnAccount.');
            }
            var localVarPath = "/v2/accounts/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an account, by ID only.
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnAccount.');
            }
            var localVarPath = "/v2/accounts/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/accounts.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (crmId) {
                localVarQueryParameter['crm_id'] = crmId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }
            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }
            if (name) {
                localVarQueryParameter['name'] = name.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (accountStageId) {
                localVarQueryParameter['account_stage_id'] = accountStageId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team.
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount: function (name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling updateAnExistingAccount.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain', 'Required parameter domain was null or undefined when calling updateAnExistingAccount.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateAnExistingAccount.');
            }
            var localVarPath = "/v2/accounts/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (domain !== undefined) {
                localVarFormParams.set('domain', domain);
            }
            if (conversationalName !== undefined) {
                localVarFormParams.set('conversational_name', conversationalName);
            }
            if (description !== undefined) {
                localVarFormParams.set('description', description);
            }
            if (phone !== undefined) {
                localVarFormParams.set('phone', phone);
            }
            if (website !== undefined) {
                localVarFormParams.set('website', website);
            }
            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl);
            }
            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle);
            }
            if (street !== undefined) {
                localVarFormParams.set('street', street);
            }
            if (city !== undefined) {
                localVarFormParams.set('city', city);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (postalCode !== undefined) {
                localVarFormParams.set('postal_code', postalCode);
            }
            if (country !== undefined) {
                localVarFormParams.set('country', country);
            }
            if (locale !== undefined) {
                localVarFormParams.set('locale', locale);
            }
            if (industry !== undefined) {
                localVarFormParams.set('industry', industry);
            }
            if (companyType !== undefined) {
                localVarFormParams.set('company_type', companyType);
            }
            if (founded !== undefined) {
                localVarFormParams.set('founded', founded);
            }
            if (revenueRange !== undefined) {
                localVarFormParams.set('revenue_range', revenueRange);
            }
            if (size !== undefined) {
                localVarFormParams.set('size', size);
            }
            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact);
            }
            if (customFields) {
                localVarFormParams.set('custom_fields', customFields.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (tags) {
                localVarFormParams.set('tags', tags.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId);
            }
            if (companyStageId !== undefined) {
                localVarFormParams.set('company_stage_id', companyStageId);
            }
            if (archived !== undefined) {
                localVarFormParams.set('archived', archived);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team.
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount: function (name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options) {
            var localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account.
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount: function (id, options) {
            var localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).deleteAnAccount(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an account, by ID only.
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount: function (id, options) {
            var localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).fetchAnAccount(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team.
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount: function (name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options) {
            var localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team.
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount: function (name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options) {
            return exports.AccountsApiFp(configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options)(fetch, basePath);
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account.
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount: function (id, options) {
            return exports.AccountsApiFp(configuration).deleteAnAccount(id, options)(fetch, basePath);
        },
        /**
         * Fetches an account, by ID only.
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount: function (id, options) {
            return exports.AccountsApiFp(configuration).fetchAnAccount(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.AccountsApiFp(configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team.
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount: function (name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options) {
            return exports.AccountsApiFp(configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options)(fetch, basePath);
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
var AccountsApi = /** @class */ (function (_super) {
    __extends(AccountsApi, _super);
    function AccountsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an account.  \"domain\" must be unique on the current team.
     * @summary Create an account
     * @param {string} name Account Full Name
     * @param {string} domain Website domain, not a fully qualified URI
     * @param {string} [conversationalName] Conversational name of the Account
     * @param {string} [description] Description
     * @param {string} [phone] Phone number without formatting
     * @param {string} [website] Website
     * @param {string} [linkedinUrl] Full LinkedIn url
     * @param {string} [twitterHandle] Twitter handle, with @
     * @param {string} [street] Street name and number
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [country] Country
     * @param {string} [locale] Time locale
     * @param {string} [industry] Industry
     * @param {string} [companyType] Type of the Account&#39;s company
     * @param {string} [founded] Date or year of founding
     * @param {string} [revenueRange] Estimated revenue range
     * @param {string} [size] Estimated number of people in employment
     * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {Array<string>} [tags] All tags applied to this Account
     * @param {number} [ownerId] ID of the User that owns this Account
     * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.createAnAccount = function (name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options) {
        return exports.AccountsApiFp(this.configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account.
     * @summary Delete an account
     * @param {string} id Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.deleteAnAccount = function (id, options) {
        return exports.AccountsApiFp(this.configuration).deleteAnAccount(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches an account, by ID only.
     * @summary Fetch an account
     * @param {string} id Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.fetchAnAccount = function (id, options) {
        return exports.AccountsApiFp(this.configuration).fetchAnAccount(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List accounts
     * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
     * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
     * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
     * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
     * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.listAccounts = function (ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.AccountsApiFp(this.configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates an account.  \"domain\" must be unique on the current team.
     * @summary Update an existing Account
     * @param {string} name Account Full Name
     * @param {string} domain Website domain, not a fully qualified URI
     * @param {string} id Account ID
     * @param {string} [conversationalName] Conversational name of the Account
     * @param {string} [description] Description
     * @param {string} [phone] Phone number without formatting
     * @param {string} [website] Website
     * @param {string} [linkedinUrl] Full LinkedIn url
     * @param {string} [twitterHandle] Twitter handle, with @
     * @param {string} [street] Street name and number
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [country] Country
     * @param {string} [locale] Time locale
     * @param {string} [industry] Industry
     * @param {string} [companyType] Type of the Account&#39;s company
     * @param {string} [founded] Date or year of founding
     * @param {string} [revenueRange] Estimated revenue range
     * @param {string} [size] Estimated number of people in employment
     * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {Array<string>} [tags] All tags applied to this Account
     * @param {number} [ownerId] ID of the User that owns this Account
     * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
     * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.updateAnExistingAccount = function (name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options) {
        return exports.AccountsApiFp(this.configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options)(this.fetch, this.basePath);
    };
    return AccountsApi;
}(BaseAPI));
exports.AccountsApi = AccountsApi;
/**
 * ActionDetailsCallInstructionsApi - fetch parameter creator
 * @export
 */
exports.ActionDetailsCallInstructionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a call instruction, by ID only.
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACallInstructions.');
            }
            var localVarPath = "/v2/action_details/call_instructions/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/action_details/call_instructions.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionDetailsCallInstructionsApi - functional programming interface
 * @export
 */
exports.ActionDetailsCallInstructionsApiFp = function (configuration) {
    return {
        /**
         * Fetches a call instruction, by ID only.
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions: function (id, options) {
            var localVarFetchArgs = exports.ActionDetailsCallInstructionsApiFetchParamCreator(configuration).fetchACallInstructions(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.ActionDetailsCallInstructionsApiFetchParamCreator(configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ActionDetailsCallInstructionsApi - factory interface
 * @export
 */
exports.ActionDetailsCallInstructionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a call instruction, by ID only.
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions: function (id, options) {
            return exports.ActionDetailsCallInstructionsApiFp(configuration).fetchACallInstructions(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.ActionDetailsCallInstructionsApiFp(configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * ActionDetailsCallInstructionsApi - object-oriented interface
 * @export
 * @class ActionDetailsCallInstructionsApi
 * @extends {BaseAPI}
 */
var ActionDetailsCallInstructionsApi = /** @class */ (function (_super) {
    __extends(ActionDetailsCallInstructionsApi, _super);
    function ActionDetailsCallInstructionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a call instruction, by ID only.
     * @summary Fetch a call instructions
     * @param {string} id Call instructions ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionDetailsCallInstructionsApi
     */
    ActionDetailsCallInstructionsApi.prototype.fetchACallInstructions = function (id, options) {
        return exports.ActionDetailsCallInstructionsApiFp(this.configuration).fetchACallInstructions(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List call instructions
     * @param {Array<number>} [ids] IDs of call instructions to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionDetailsCallInstructionsApi
     */
    ActionDetailsCallInstructionsApi.prototype.listCallInstructions = function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.ActionDetailsCallInstructionsApiFp(this.configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return ActionDetailsCallInstructionsApi;
}(BaseAPI));
exports.ActionDetailsCallInstructionsApi = ActionDetailsCallInstructionsApi;
/**
 * ActionsApi - fetch parameter creator
 * @export
 */
exports.ActionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code.
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnAction.');
            }
            var localVarPath = "/v2/actions/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter.
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions: function (ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/actions.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (stepId !== undefined) {
                localVarQueryParameter['step_id'] = stepId;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (dueOn) {
                localVarQueryParameter['due_on'] = dueOn.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (userGuid) {
                localVarQueryParameter['user_guid'] = userGuid.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (personId) {
                localVarQueryParameter['person_id'] = personId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
exports.ActionsApiFp = function (configuration) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code.
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction: function (id, options) {
            var localVarFetchArgs = exports.ActionsApiFetchParamCreator(configuration).fetchAnAction(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter.
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions: function (ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.ActionsApiFetchParamCreator(configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
exports.ActionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code.
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction: function (id, options) {
            return exports.ActionsApiFp(configuration).fetchAnAction(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter.
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions: function (ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.ActionsApiFp(configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
var ActionsApi = /** @class */ (function (_super) {
    __extends(ActionsApi, _super);
    function ActionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code.
     * @summary Fetch an action
     * @param {string} id Action ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.fetchAnAction = function (id, options) {
        return exports.ActionsApiFp(this.configuration).fetchAnAction(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter.
     * @summary List actions
     * @param {Array<number>} [ids] IDs of actions to fetch.
     * @param {number} [stepId] Fetch actions by step ID
     * @param {string} [type] Filter actions by type
     * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
     * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.listActions = function (ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.ActionsApiFp(this.configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return ActionsApi;
}(BaseAPI));
exports.ActionsApi = ActionsApi;
/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
exports.ActivitiesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them.
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity: function (actionId, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/activities.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
exports.ActivitiesApiFp = function (configuration) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them.
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity: function (actionId, options) {
            var localVarFetchArgs = exports.ActivitiesApiFetchParamCreator(configuration).createAnActivity(actionId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
exports.ActivitiesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them.
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity: function (actionId, options) {
            return exports.ActivitiesApiFp(configuration).createAnActivity(actionId, options)(fetch, basePath);
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
var ActivitiesApi = /** @class */ (function (_super) {
    __extends(ActivitiesApi, _super);
    function ActivitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them.
     * @summary Create an activity
     * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    ActivitiesApi.prototype.createAnActivity = function (actionId, options) {
        return exports.ActivitiesApiFp(this.configuration).createAnActivity(actionId, options)(this.fetch, this.basePath);
    };
    return ActivitiesApi;
}(BaseAPI));
exports.ActivitiesApi = ActivitiesApi;
/**
 * CRMActivitiesApi - fetch parameter creator
 * @export
 */
exports.CRMActivitiesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a crm activity, by ID only.
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACrmActivity.');
            }
            var localVarPath = "/v2/crm_activities/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/crm_activities.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CRMActivitiesApi - functional programming interface
 * @export
 */
exports.CRMActivitiesApiFp = function (configuration) {
    return {
        /**
         * Fetches a crm activity, by ID only.
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity: function (id, options) {
            var localVarFetchArgs = exports.CRMActivitiesApiFetchParamCreator(configuration).fetchACrmActivity(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CRMActivitiesApiFetchParamCreator(configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CRMActivitiesApi - factory interface
 * @export
 */
exports.CRMActivitiesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a crm activity, by ID only.
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity: function (id, options) {
            return exports.CRMActivitiesApiFp(configuration).fetchACrmActivity(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CRMActivitiesApiFp(configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CRMActivitiesApi - object-oriented interface
 * @export
 * @class CRMActivitiesApi
 * @extends {BaseAPI}
 */
var CRMActivitiesApi = /** @class */ (function (_super) {
    __extends(CRMActivitiesApi, _super);
    function CRMActivitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a crm activity, by ID only.
     * @summary Fetch a crm activity
     * @param {string} id Crm activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivitiesApi
     */
    CRMActivitiesApi.prototype.fetchACrmActivity = function (id, options) {
        return exports.CRMActivitiesApiFp(this.configuration).fetchACrmActivity(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List crm activities
     * @param {Array<number>} [ids] IDs of crm activities to fetch.
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivitiesApi
     */
    CRMActivitiesApi.prototype.listCrmActivities = function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CRMActivitiesApiFp(this.configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CRMActivitiesApi;
}(BaseAPI));
exports.CRMActivitiesApi = CRMActivitiesApi;
/**
 * CRMActivityFieldsApi - fetch parameter creator
 * @export
 */
exports.CRMActivityFieldsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields: function (source, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/crm_activity_fields.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CRMActivityFieldsApi - functional programming interface
 * @export
 */
exports.CRMActivityFieldsApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields: function (source, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CRMActivityFieldsApiFetchParamCreator(configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CRMActivityFieldsApi - factory interface
 * @export
 */
exports.CRMActivityFieldsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields: function (source, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CRMActivityFieldsApiFp(configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CRMActivityFieldsApi - object-oriented interface
 * @export
 * @class CRMActivityFieldsApi
 * @extends {BaseAPI}
 */
var CRMActivityFieldsApi = /** @class */ (function (_super) {
    __extends(CRMActivityFieldsApi, _super);
    function CRMActivityFieldsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List crm activity fields
     * @param {string} [source] Return only records with this source
     * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivityFieldsApi
     */
    CRMActivityFieldsApi.prototype.listCrmActivityFields = function (source, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CRMActivityFieldsApiFp(this.configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CRMActivityFieldsApi;
}(BaseAPI));
exports.CRMActivityFieldsApi = CRMActivityFieldsApi;
/**
 * CadenceMembershipsApi - fetch parameter creator
 * @export
 */
exports.CadenceMembershipsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate.
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership: function (personId, cadenceId, userId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId', 'Required parameter personId was null or undefined when calling createACadenceMembership.');
            }
            // verify required parameter 'cadenceId' is not null or undefined
            if (cadenceId === null || cadenceId === undefined) {
                throw new RequiredError('cadenceId', 'Required parameter cadenceId was null or undefined when calling createACadenceMembership.');
            }
            var localVarPath = "/v2/cadence_memberships.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (personId !== undefined) {
                localVarQueryParameter['person_id'] = personId;
            }
            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteACadenceMembership.');
            }
            var localVarPath = "/v2/cadence_memberships/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a cadence membership, by ID only.
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACadenceMembership.');
            }
            var localVarPath = "/v2/cadence_memberships/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record.
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships: function (ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/cadence_memberships.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (personId !== undefined) {
                localVarQueryParameter['person_id'] = personId;
            }
            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (currentlyOnCadence !== undefined) {
                localVarQueryParameter['currently_on_cadence'] = currentlyOnCadence;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CadenceMembershipsApi - functional programming interface
 * @export
 */
exports.CadenceMembershipsApiFp = function (configuration) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate.
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership: function (personId, cadenceId, userId, options) {
            var localVarFetchArgs = exports.CadenceMembershipsApiFetchParamCreator(configuration).createACadenceMembership(personId, cadenceId, userId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership: function (id, options) {
            var localVarFetchArgs = exports.CadenceMembershipsApiFetchParamCreator(configuration).deleteACadenceMembership(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a cadence membership, by ID only.
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership: function (id, options) {
            var localVarFetchArgs = exports.CadenceMembershipsApiFetchParamCreator(configuration).fetchACadenceMembership(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record.
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships: function (ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CadenceMembershipsApiFetchParamCreator(configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CadenceMembershipsApi - factory interface
 * @export
 */
exports.CadenceMembershipsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate.
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership: function (personId, cadenceId, userId, options) {
            return exports.CadenceMembershipsApiFp(configuration).createACadenceMembership(personId, cadenceId, userId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership: function (id, options) {
            return exports.CadenceMembershipsApiFp(configuration).deleteACadenceMembership(id, options)(fetch, basePath);
        },
        /**
         * Fetches a cadence membership, by ID only.
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership: function (id, options) {
            return exports.CadenceMembershipsApiFp(configuration).fetchACadenceMembership(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record.
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships: function (ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CadenceMembershipsApiFp(configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CadenceMembershipsApi - object-oriented interface
 * @export
 * @class CadenceMembershipsApi
 * @extends {BaseAPI}
 */
var CadenceMembershipsApi = /** @class */ (function (_super) {
    __extends(CadenceMembershipsApi, _super);
    function CadenceMembershipsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate.
     * @summary Create a cadence membership
     * @param {number} personId ID of the person to create a cadence membership for
     * @param {number} cadenceId ID of the cadence to create a cadence membership for
     * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    CadenceMembershipsApi.prototype.createACadenceMembership = function (personId, cadenceId, userId, options) {
        return exports.CadenceMembershipsApiFp(this.configuration).createACadenceMembership(personId, cadenceId, userId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete a cadence membership
     * @param {string} id CadenceMembership ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    CadenceMembershipsApi.prototype.deleteACadenceMembership = function (id, options) {
        return exports.CadenceMembershipsApiFp(this.configuration).deleteACadenceMembership(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a cadence membership, by ID only.
     * @summary Fetch a cadence membership
     * @param {string} id CadenceMembership ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    CadenceMembershipsApi.prototype.fetchACadenceMembership = function (id, options) {
        return exports.CadenceMembershipsApiFp(this.configuration).fetchACadenceMembership(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record.
     * @summary List cadence memberships
     * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {number} [personId] ID of the person to find cadence memberships for
     * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
     * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    CadenceMembershipsApi.prototype.listCadenceMemberships = function (ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CadenceMembershipsApiFp(this.configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CadenceMembershipsApi;
}(BaseAPI));
exports.CadenceMembershipsApi = CadenceMembershipsApi;
/**
 * CadencesApi - fetch parameter creator
 * @export
 */
exports.CadencesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a cadence, by ID only.
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACadence.');
            }
            var localVarPath = "/v2/cadences/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences: function (ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/cadences.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (teamCadence !== undefined) {
                localVarQueryParameter['team_cadence'] = teamCadence;
            }
            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }
            if (ownedByGuid) {
                localVarQueryParameter['owned_by_guid'] = ownedByGuid.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (peopleAddable !== undefined) {
                localVarQueryParameter['people_addable'] = peopleAddable;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CadencesApi - functional programming interface
 * @export
 */
exports.CadencesApiFp = function (configuration) {
    return {
        /**
         * Fetches a cadence, by ID only.
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence: function (id, options) {
            var localVarFetchArgs = exports.CadencesApiFetchParamCreator(configuration).fetchACadence(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences: function (ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CadencesApiFetchParamCreator(configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CadencesApi - factory interface
 * @export
 */
exports.CadencesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a cadence, by ID only.
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence: function (id, options) {
            return exports.CadencesApiFp(configuration).fetchACadence(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences: function (ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CadencesApiFp(configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CadencesApi - object-oriented interface
 * @export
 * @class CadencesApi
 * @extends {BaseAPI}
 */
var CadencesApi = /** @class */ (function (_super) {
    __extends(CadencesApi, _super);
    function CadencesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a cadence, by ID only.
     * @summary Fetch a cadence
     * @param {string} id Cadence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadencesApi
     */
    CadencesApi.prototype.fetchACadence = function (id, options) {
        return exports.CadencesApiFp(this.configuration).fetchACadence(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List cadences
     * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
     * @param {boolean} [shared] Filters cadences by whether they are shared
     * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
     * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadencesApi
     */
    CadencesApi.prototype.listCadences = function (ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CadencesApiFp(this.configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CadencesApi;
}(BaseAPI));
exports.CadencesApi = CadencesApi;
/**
 * CallDataRecordsApi - fetch parameter creator
 * @export
 */
exports.CallDataRecordsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a call data record, by ID only.
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACallDataRecord.');
            }
            var localVarPath = "/v2/call_data_records/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be.
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords: function (ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/call_data_records.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (hasCall !== undefined) {
                localVarQueryParameter['has_call'] = hasCall;
            }
            if (createdAt) {
                localVarQueryParameter['created_at'] = createdAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (userGuid) {
                localVarQueryParameter['user_guid'] = userGuid.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CallDataRecordsApi - functional programming interface
 * @export
 */
exports.CallDataRecordsApiFp = function (configuration) {
    return {
        /**
         * Fetches a call data record, by ID only.
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord: function (id, options) {
            var localVarFetchArgs = exports.CallDataRecordsApiFetchParamCreator(configuration).fetchACallDataRecord(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be.
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords: function (ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CallDataRecordsApiFetchParamCreator(configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CallDataRecordsApi - factory interface
 * @export
 */
exports.CallDataRecordsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a call data record, by ID only.
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord: function (id, options) {
            return exports.CallDataRecordsApiFp(configuration).fetchACallDataRecord(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be.
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords: function (ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CallDataRecordsApiFp(configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CallDataRecordsApi - object-oriented interface
 * @export
 * @class CallDataRecordsApi
 * @extends {BaseAPI}
 */
var CallDataRecordsApi = /** @class */ (function (_super) {
    __extends(CallDataRecordsApi, _super);
    function CallDataRecordsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a call data record, by ID only.
     * @summary Fetch a call data record
     * @param {string} id CallDataRecord ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDataRecordsApi
     */
    CallDataRecordsApi.prototype.fetchACallDataRecord = function (id, options) {
        return exports.CallDataRecordsApiFp(this.configuration).fetchACallDataRecord(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be.
     * @summary List call data records
     * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
     * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {Array<string>} [userGuid] Filters list to only include guids
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDataRecordsApi
     */
    CallDataRecordsApi.prototype.listCallDataRecords = function (ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CallDataRecordsApiFp(this.configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CallDataRecordsApi;
}(BaseAPI));
exports.CallDataRecordsApi = CallDataRecordsApi;
/**
 * CallDispositionsApi - fetch parameter creator
 * @export
 */
exports.CallDispositionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/call_dispositions.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CallDispositionsApi - functional programming interface
 * @export
 */
exports.CallDispositionsApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CallDispositionsApiFetchParamCreator(configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CallDispositionsApi - factory interface
 * @export
 */
exports.CallDispositionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CallDispositionsApiFp(configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CallDispositionsApi - object-oriented interface
 * @export
 * @class CallDispositionsApi
 * @extends {BaseAPI}
 */
var CallDispositionsApi = /** @class */ (function (_super) {
    __extends(CallDispositionsApi, _super);
    function CallDispositionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
     * @summary List call dispositions
     * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDispositionsApi
     */
    CallDispositionsApi.prototype.listCallDispositions = function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CallDispositionsApiFp(this.configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CallDispositionsApi;
}(BaseAPI));
exports.CallDispositionsApi = CallDispositionsApi;
/**
 * CallSentimentsApi - fetch parameter creator
 * @export
 */
exports.CallSentimentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/call_sentiments.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CallSentimentsApi - functional programming interface
 * @export
 */
exports.CallSentimentsApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CallSentimentsApiFetchParamCreator(configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CallSentimentsApi - factory interface
 * @export
 */
exports.CallSentimentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments: function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CallSentimentsApiFp(configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CallSentimentsApi - object-oriented interface
 * @export
 * @class CallSentimentsApi
 * @extends {BaseAPI}
 */
var CallSentimentsApi = /** @class */ (function (_super) {
    __extends(CallSentimentsApi, _super);
    function CallSentimentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case.
     * @summary List call sentiments
     * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallSentimentsApi
     */
    CallSentimentsApi.prototype.listCallSentiments = function (sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CallSentimentsApiFp(this.configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CallSentimentsApi;
}(BaseAPI));
exports.CallSentimentsApi = CallSentimentsApi;
/**
 * CallerIDsApi - fetch parameter creator
 * @export
 */
exports.CallerIDsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format.
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds: function (phoneNumber, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'phoneNumber' is not null or undefined
            if (phoneNumber === null || phoneNumber === undefined) {
                throw new RequiredError('phoneNumber', 'Required parameter phoneNumber was null or undefined when calling listCallerIds.');
            }
            var localVarPath = "/v2/phone_numbers/caller_ids.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (phoneNumber !== undefined) {
                localVarQueryParameter['phone_number'] = phoneNumber;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CallerIDsApi - functional programming interface
 * @export
 */
exports.CallerIDsApiFp = function (configuration) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format.
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds: function (phoneNumber, options) {
            var localVarFetchArgs = exports.CallerIDsApiFetchParamCreator(configuration).listCallerIds(phoneNumber, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CallerIDsApi - factory interface
 * @export
 */
exports.CallerIDsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format.
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds: function (phoneNumber, options) {
            return exports.CallerIDsApiFp(configuration).listCallerIds(phoneNumber, options)(fetch, basePath);
        },
    };
};
/**
 * CallerIDsApi - object-oriented interface
 * @export
 * @class CallerIDsApi
 * @extends {BaseAPI}
 */
var CallerIDsApi = /** @class */ (function (_super) {
    __extends(CallerIDsApi, _super);
    function CallerIDsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format.
     * @summary List caller ids
     * @param {string} phoneNumber E.164 Phone Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallerIDsApi
     */
    CallerIDsApi.prototype.listCallerIds = function (phoneNumber, options) {
        return exports.CallerIDsApiFp(this.configuration).listCallerIds(phoneNumber, options)(this.fetch, this.basePath);
    };
    return CallerIDsApi;
}(BaseAPI));
exports.CallerIDsApi = CallerIDsApi;
/**
 * CallsApi - fetch parameter creator
 * @export
 */
exports.CallsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly.
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;.
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied.
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall: function (personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId', 'Required parameter personId was null or undefined when calling createACall.');
            }
            var localVarPath = "/v2/activities/calls.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (personId !== undefined) {
                localVarFormParams.set('person_id', personId);
            }
            if (to !== undefined) {
                localVarFormParams.set('to', to);
            }
            if (duration !== undefined) {
                localVarFormParams.set('duration', duration);
            }
            if (disposition !== undefined) {
                localVarFormParams.set('disposition', disposition);
            }
            if (sentiment !== undefined) {
                localVarFormParams.set('sentiment', sentiment);
            }
            if (notes !== undefined) {
                localVarFormParams.set('notes', notes);
            }
            if (userGuid !== undefined) {
                localVarFormParams.set('user_guid', userGuid);
            }
            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId);
            }
            if (crmParams !== undefined) {
                localVarFormParams.set('crm_params', crmParams);
            }
            if (linkedCallDataRecordIds) {
                localVarFormParams.set('linked_call_data_record_ids', linkedCallDataRecordIds.join(exports.COLLECTION_FORMATS["csv"]));
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a call, by ID only.
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACall.');
            }
            var localVarPath = "/v2/activities/calls/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/activities/calls.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CallsApi - functional programming interface
 * @export
 */
exports.CallsApiFp = function (configuration) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly.
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;.
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied.
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall: function (personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options) {
            var localVarFetchArgs = exports.CallsApiFetchParamCreator(configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a call, by ID only.
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall: function (id, options) {
            var localVarFetchArgs = exports.CallsApiFetchParamCreator(configuration).fetchACall(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CallsApiFetchParamCreator(configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CallsApi - factory interface
 * @export
 */
exports.CallsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly.
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;.
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied.
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall: function (personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options) {
            return exports.CallsApiFp(configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options)(fetch, basePath);
        },
        /**
         * Fetches a call, by ID only.
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall: function (id, options) {
            return exports.CallsApiFp(configuration).fetchACall(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls: function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CallsApiFp(configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * CallsApi - object-oriented interface
 * @export
 * @class CallsApi
 * @extends {BaseAPI}
 */
var CallsApi = /** @class */ (function (_super) {
    __extends(CallsApi, _super);
    function CallsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly.
     * @summary Create a call
     * @param {number} personId The ID of the person whom this call will be logged for
     * @param {string} [to] The phone number that was called
     * @param {number} [duration] The length of the call, in seconds
     * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
     * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
     * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
     * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
     * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;.
     * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied.
     * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    CallsApi.prototype.createACall = function (personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options) {
        return exports.CallsApiFp(this.configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a call, by ID only.
     * @summary Fetch a call
     * @param {string} id Call ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    CallsApi.prototype.fetchACall = function (id, options) {
        return exports.CallsApiFp(this.configuration).fetchACall(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List calls
     * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    CallsApi.prototype.listCalls = function (ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CallsApiFp(this.configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return CallsApi;
}(BaseAPI));
exports.CallsApi = CallsApi;
/**
 * CustomFieldsApi - fetch parameter creator
 * @export
 */
exports.CustomFieldsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a custom field.
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField: function (name, fieldType, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling createACustomField.');
            }
            var localVarPath = "/v2/custom_fields.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (fieldType !== undefined) {
                localVarFormParams.set('field_type', fieldType);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom field.
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteACustomField.');
            }
            var localVarPath = "/v2/custom_fields/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a custom field, by ID only.
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchACustomField.');
            }
            var localVarPath = "/v2/custom_fields/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields: function (ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/custom_fields.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (fieldType !== undefined) {
                localVarQueryParameter['field_type'] = fieldType;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a custom field.
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField: function (id, name, fieldType, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateACustomField.');
            }
            var localVarPath = "/v2/custom_fields/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (fieldType !== undefined) {
                localVarFormParams.set('field_type', fieldType);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CustomFieldsApi - functional programming interface
 * @export
 */
exports.CustomFieldsApiFp = function (configuration) {
    return {
        /**
         * Creates a custom field.
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField: function (name, fieldType, options) {
            var localVarFetchArgs = exports.CustomFieldsApiFetchParamCreator(configuration).createACustomField(name, fieldType, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a custom field.
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField: function (id, options) {
            var localVarFetchArgs = exports.CustomFieldsApiFetchParamCreator(configuration).deleteACustomField(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a custom field, by ID only.
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField: function (id, options) {
            var localVarFetchArgs = exports.CustomFieldsApiFetchParamCreator(configuration).fetchACustomField(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields: function (ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.CustomFieldsApiFetchParamCreator(configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a custom field.
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField: function (id, name, fieldType, options) {
            var localVarFetchArgs = exports.CustomFieldsApiFetchParamCreator(configuration).updateACustomField(id, name, fieldType, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CustomFieldsApi - factory interface
 * @export
 */
exports.CustomFieldsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a custom field.
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField: function (name, fieldType, options) {
            return exports.CustomFieldsApiFp(configuration).createACustomField(name, fieldType, options)(fetch, basePath);
        },
        /**
         * Deletes a custom field.
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField: function (id, options) {
            return exports.CustomFieldsApiFp(configuration).deleteACustomField(id, options)(fetch, basePath);
        },
        /**
         * Fetches a custom field, by ID only.
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField: function (id, options) {
            return exports.CustomFieldsApiFp(configuration).fetchACustomField(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields: function (ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.CustomFieldsApiFp(configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Update a custom field.
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField: function (id, name, fieldType, options) {
            return exports.CustomFieldsApiFp(configuration).updateACustomField(id, name, fieldType, options)(fetch, basePath);
        },
    };
};
/**
 * CustomFieldsApi - object-oriented interface
 * @export
 * @class CustomFieldsApi
 * @extends {BaseAPI}
 */
var CustomFieldsApi = /** @class */ (function (_super) {
    __extends(CustomFieldsApi, _super);
    function CustomFieldsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a custom field.
     * @summary Create a custom field
     * @param {string} name The name of the custom field
     * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    CustomFieldsApi.prototype.createACustomField = function (name, fieldType, options) {
        return exports.CustomFieldsApiFp(this.configuration).createACustomField(name, fieldType, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a custom field.
     * @summary Delete a custom field
     * @param {string} id Custom Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    CustomFieldsApi.prototype.deleteACustomField = function (id, options) {
        return exports.CustomFieldsApiFp(this.configuration).deleteACustomField(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a custom field, by ID only.
     * @summary Fetch a custom field
     * @param {string} id Custom Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    CustomFieldsApi.prototype.fetchACustomField = function (id, options) {
        return exports.CustomFieldsApiFp(this.configuration).fetchACustomField(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List custom fields
     * @param {Array<number>} [ids] IDs of custom fields to fetch.
     * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    CustomFieldsApi.prototype.listCustomFields = function (ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.CustomFieldsApiFp(this.configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Update a custom field.
     * @summary Update a custom field
     * @param {string} id Custom Field ID
     * @param {string} [name] The name of the custom field
     * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    CustomFieldsApi.prototype.updateACustomField = function (id, name, fieldType, options) {
        return exports.CustomFieldsApiFp(this.configuration).updateACustomField(id, name, fieldType, options)(this.fetch, this.basePath);
    };
    return CustomFieldsApi;
}(BaseAPI));
exports.CustomFieldsApi = CustomFieldsApi;
/**
 * EmailTemplateAttachmentsApi - fetch parameter creator
 * @export
 */
exports.EmailTemplateAttachmentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments: function (ids, emailTemplateId, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/email_template_attachments.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (emailTemplateId) {
                localVarQueryParameter['email_template_id'] = emailTemplateId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmailTemplateAttachmentsApi - functional programming interface
 * @export
 */
exports.EmailTemplateAttachmentsApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments: function (ids, emailTemplateId, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.EmailTemplateAttachmentsApiFetchParamCreator(configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmailTemplateAttachmentsApi - factory interface
 * @export
 */
exports.EmailTemplateAttachmentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments: function (ids, emailTemplateId, perPage, page, includePagingCounts, options) {
            return exports.EmailTemplateAttachmentsApiFp(configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * EmailTemplateAttachmentsApi - object-oriented interface
 * @export
 * @class EmailTemplateAttachmentsApi
 * @extends {BaseAPI}
 */
var EmailTemplateAttachmentsApi = /** @class */ (function (_super) {
    __extends(EmailTemplateAttachmentsApi, _super);
    function EmailTemplateAttachmentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters.
     * @summary List email template attachments
     * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateAttachmentsApi
     */
    EmailTemplateAttachmentsApi.prototype.listEmailTemplateAttachments = function (ids, emailTemplateId, perPage, page, includePagingCounts, options) {
        return exports.EmailTemplateAttachmentsApiFp(this.configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return EmailTemplateAttachmentsApi;
}(BaseAPI));
exports.EmailTemplateAttachmentsApi = EmailTemplateAttachmentsApi;
/**
 * EmailTemplatesApi - fetch parameter creator
 * @export
 */
exports.EmailTemplatesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches an email template, by ID only.
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate: function (id, includeSignature, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnEmailTemplate.');
            }
            var localVarPath = "/v2/email_templates/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (includeSignature !== undefined) {
                localVarQueryParameter['include_signature'] = includeSignature;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates: function (ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/email_templates.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (linkedToTeamTemplate !== undefined) {
                localVarQueryParameter['linked_to_team_template'] = linkedToTeamTemplate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (filterByOwner !== undefined) {
                localVarQueryParameter['filter_by_owner'] = filterByOwner;
            }
            if (groupId) {
                localVarQueryParameter['group_id'] = groupId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (includeCadenceTemplates !== undefined) {
                localVarQueryParameter['include_cadence_templates'] = includeCadenceTemplates;
            }
            if (includeArchivedTemplates !== undefined) {
                localVarQueryParameter['include_archived_templates'] = includeArchivedTemplates;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmailTemplatesApi - functional programming interface
 * @export
 */
exports.EmailTemplatesApiFp = function (configuration) {
    return {
        /**
         * Fetches an email template, by ID only.
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate: function (id, includeSignature, options) {
            var localVarFetchArgs = exports.EmailTemplatesApiFetchParamCreator(configuration).fetchAnEmailTemplate(id, includeSignature, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates: function (ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.EmailTemplatesApiFetchParamCreator(configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmailTemplatesApi - factory interface
 * @export
 */
exports.EmailTemplatesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches an email template, by ID only.
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate: function (id, includeSignature, options) {
            return exports.EmailTemplatesApiFp(configuration).fetchAnEmailTemplate(id, includeSignature, options)(fetch, basePath);
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates: function (ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.EmailTemplatesApiFp(configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * EmailTemplatesApi - object-oriented interface
 * @export
 * @class EmailTemplatesApi
 * @extends {BaseAPI}
 */
var EmailTemplatesApi = /** @class */ (function (_super) {
    __extends(EmailTemplatesApi, _super);
    function EmailTemplatesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches an email template, by ID only.
     * @summary Fetch an email template
     * @param {string} id EmailTemplate ID
     * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplatesApi
     */
    EmailTemplatesApi.prototype.fetchAnEmailTemplate = function (id, includeSignature, options) {
        return exports.EmailTemplatesApiFp(this.configuration).fetchAnEmailTemplate(id, includeSignature, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List email templates
     * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
     * @param {string} [search] Filters email templates by title or subject
     * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
     * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
     * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
     * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
     * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
     * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplatesApi
     */
    EmailTemplatesApi.prototype.listEmailTemplates = function (ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.EmailTemplatesApiFp(this.configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return EmailTemplatesApi;
}(BaseAPI));
exports.EmailTemplatesApi = EmailTemplatesApi;
/**
 * EmailsApi - fetch parameter creator
 * @export
 */
exports.EmailsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches an email, by ID only.
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnEmail.');
            }
            var localVarPath = "/v2/activities/emails/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails: function (ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/activities/emails.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (bounced !== undefined) {
                localVarQueryParameter['bounced'] = bounced;
            }
            if (crmActivityId) {
                localVarQueryParameter['crm_activity_id'] = crmActivityId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (actionId) {
                localVarQueryParameter['action_id'] = actionId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmailsApi - functional programming interface
 * @export
 */
exports.EmailsApiFp = function (configuration) {
    return {
        /**
         * Fetches an email, by ID only.
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail: function (id, options) {
            var localVarFetchArgs = exports.EmailsApiFetchParamCreator(configuration).fetchAnEmail(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails: function (ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.EmailsApiFetchParamCreator(configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmailsApi - factory interface
 * @export
 */
exports.EmailsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches an email, by ID only.
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail: function (id, options) {
            return exports.EmailsApiFp(configuration).fetchAnEmail(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails: function (ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.EmailsApiFp(configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * EmailsApi - object-oriented interface
 * @export
 * @class EmailsApi
 * @extends {BaseAPI}
 */
var EmailsApi = /** @class */ (function (_super) {
    __extends(EmailsApi, _super);
    function EmailsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches an email, by ID only.
     * @summary Fetch an email
     * @param {string} id Email ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    EmailsApi.prototype.fetchAnEmail = function (id, options) {
        return exports.EmailsApiFp(this.configuration).fetchAnEmail(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List emails
     * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {boolean} [bounced] Filters emails by whether they have bounced or not
     * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
     * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    EmailsApi.prototype.listEmails = function (ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.EmailsApiFp(this.configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return EmailsApi;
}(BaseAPI));
exports.EmailsApi = EmailsApi;
/**
 * ImportsApi - fetch parameter creator
 * @export
 */
exports.ImportsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an import.
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport: function (userId, name, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/imports.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (userId !== undefined) {
                localVarFormParams.set('user_id', userId);
            }
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport: function (id, undo, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteAnImport.');
            }
            var localVarPath = "/v2/imports/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (undo !== undefined) {
                localVarQueryParameter['undo'] = undo;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAnImport.');
            }
            var localVarPath = "/v2/imports/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple imports.
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports: function (ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/imports.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport: function (id, userId, name, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateAnImport.');
            }
            var localVarPath = "/v2/imports/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (userId !== undefined) {
                localVarFormParams.set('user_id', userId);
            }
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ImportsApi - functional programming interface
 * @export
 */
exports.ImportsApiFp = function (configuration) {
    return {
        /**
         * Creates an import.
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport: function (userId, name, options) {
            var localVarFetchArgs = exports.ImportsApiFetchParamCreator(configuration).createAnImport(userId, name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport: function (id, undo, options) {
            var localVarFetchArgs = exports.ImportsApiFetchParamCreator(configuration).deleteAnImport(id, undo, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport: function (id, options) {
            var localVarFetchArgs = exports.ImportsApiFetchParamCreator(configuration).fetchAnImport(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple imports.
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports: function (ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.ImportsApiFetchParamCreator(configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport: function (id, userId, name, options) {
            var localVarFetchArgs = exports.ImportsApiFetchParamCreator(configuration).updateAnImport(id, userId, name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ImportsApi - factory interface
 * @export
 */
exports.ImportsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an import.
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport: function (userId, name, options) {
            return exports.ImportsApiFp(configuration).createAnImport(userId, name, options)(fetch, basePath);
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport: function (id, undo, options) {
            return exports.ImportsApiFp(configuration).deleteAnImport(id, undo, options)(fetch, basePath);
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport: function (id, options) {
            return exports.ImportsApiFp(configuration).fetchAnImport(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple imports.
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports: function (ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.ImportsApiFp(configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport: function (id, userId, name, options) {
            return exports.ImportsApiFp(configuration).updateAnImport(id, userId, name, options)(fetch, basePath);
        },
    };
};
/**
 * ImportsApi - object-oriented interface
 * @export
 * @class ImportsApi
 * @extends {BaseAPI}
 */
var ImportsApi = /** @class */ (function (_super) {
    __extends(ImportsApi, _super);
    function ImportsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an import.
     * @summary Create an import
     * @param {number} [userId] ID of the User that owns this Import
     * @param {string} [name] Name, recommended to be easily identifiable to a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    ImportsApi.prototype.createAnImport = function (userId, name, options) {
        return exports.ImportsApiFp(this.configuration).createAnImport(userId, name, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
     * @summary Delete an import
     * @param {string} id Import ID
     * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    ImportsApi.prototype.deleteAnImport = function (id, undo, options) {
        return exports.ImportsApiFp(this.configuration).deleteAnImport(id, undo, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
     * @summary Fetch an import
     * @param {string} id Import ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    ImportsApi.prototype.fetchAnImport = function (id, options) {
        return exports.ImportsApiFp(this.configuration).fetchAnImport(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple imports.
     * @summary List imports
     * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    ImportsApi.prototype.listImports = function (ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.ImportsApiFp(this.configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports.
     * @summary Update an import
     * @param {string} id Import ID
     * @param {number} [userId] ID of the User that owns this Import
     * @param {string} [name] Name, recommended to be easily identifiable to a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    ImportsApi.prototype.updateAnImport = function (id, userId, name, options) {
        return exports.ImportsApiFp(this.configuration).updateAnImport(id, userId, name, options)(this.fetch, this.basePath);
    };
    return ImportsApi;
}(BaseAPI));
exports.ImportsApi = ImportsApi;
/**
 * LiveWebsiteTrackingParametersApi - fetch parameter creator
 * @export
 */
exports.LiveWebsiteTrackingParametersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter: function (personId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId', 'Required parameter personId was null or undefined when calling createAnLiveWebsiteTrackingParameter.');
            }
            var localVarPath = "/v2/live_website_tracking_parameters.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (personId !== undefined) {
                localVarFormParams.set('person_id', personId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LiveWebsiteTrackingParametersApi - functional programming interface
 * @export
 */
exports.LiveWebsiteTrackingParametersApiFp = function (configuration) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter: function (personId, options) {
            var localVarFetchArgs = exports.LiveWebsiteTrackingParametersApiFetchParamCreator(configuration).createAnLiveWebsiteTrackingParameter(personId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * LiveWebsiteTrackingParametersApi - factory interface
 * @export
 */
exports.LiveWebsiteTrackingParametersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter: function (personId, options) {
            return exports.LiveWebsiteTrackingParametersApiFp(configuration).createAnLiveWebsiteTrackingParameter(personId, options)(fetch, basePath);
        },
    };
};
/**
 * LiveWebsiteTrackingParametersApi - object-oriented interface
 * @export
 * @class LiveWebsiteTrackingParametersApi
 * @extends {BaseAPI}
 */
var LiveWebsiteTrackingParametersApi = /** @class */ (function (_super) {
    __extends(LiveWebsiteTrackingParametersApi, _super);
    function LiveWebsiteTrackingParametersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a Live Website Tracking parameter to identify a person
     * @summary Create an Live Website Tracking Parameter
     * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveWebsiteTrackingParametersApi
     */
    LiveWebsiteTrackingParametersApi.prototype.createAnLiveWebsiteTrackingParameter = function (personId, options) {
        return exports.LiveWebsiteTrackingParametersApiFp(this.configuration).createAnLiveWebsiteTrackingParameter(personId, options)(this.fetch, this.basePath);
    };
    return LiveWebsiteTrackingParametersApi;
}(BaseAPI));
exports.LiveWebsiteTrackingParametersApi = LiveWebsiteTrackingParametersApi;
/**
 * MeApi - fetch parameter creator
 * @export
 */
exports.MeApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team.
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/me.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MeApi - functional programming interface
 * @export
 */
exports.MeApiFp = function (configuration) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team.
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser: function (options) {
            var localVarFetchArgs = exports.MeApiFetchParamCreator(configuration).fetchCurrentUser(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * MeApi - factory interface
 * @export
 */
exports.MeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team.
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser: function (options) {
            return exports.MeApiFp(configuration).fetchCurrentUser(options)(fetch, basePath);
        },
    };
};
/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
var MeApi = /** @class */ (function (_super) {
    __extends(MeApi, _super);
    function MeApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team.
     * @summary Fetch current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    MeApi.prototype.fetchCurrentUser = function (options) {
        return exports.MeApiFp(this.configuration).fetchCurrentUser(options)(this.fetch, this.basePath);
    };
    return MeApi;
}(BaseAPI));
exports.MeApi = MeApi;
/**
 * NotesApi - fetch parameter creator
 * @export
 */
exports.NotesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a note.
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote: function (content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content', 'Required parameter content was null or undefined when calling createANote.');
            }
            // verify required parameter 'associatedWithType' is not null or undefined
            if (associatedWithType === null || associatedWithType === undefined) {
                throw new RequiredError('associatedWithType', 'Required parameter associatedWithType was null or undefined when calling createANote.');
            }
            // verify required parameter 'associatedWithId' is not null or undefined
            if (associatedWithId === null || associatedWithId === undefined) {
                throw new RequiredError('associatedWithId', 'Required parameter associatedWithId was null or undefined when calling createANote.');
            }
            var localVarPath = "/v2/notes.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (content !== undefined) {
                localVarFormParams.set('content', content);
            }
            if (associatedWithType !== undefined) {
                localVarFormParams.set('associated_with_type', associatedWithType);
            }
            if (associatedWithId !== undefined) {
                localVarFormParams.set('associated_with_id', associatedWithId);
            }
            if (skipCrmSync !== undefined) {
                localVarFormParams.set('skip_crm_sync', skipCrmSync);
            }
            if (callId !== undefined) {
                localVarFormParams.set('call_id', callId);
            }
            if (subject !== undefined) {
                localVarFormParams.set('subject', subject);
            }
            if (userGuid !== undefined) {
                localVarFormParams.set('user_guid', userGuid);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteANote.');
            }
            var localVarPath = "/v2/notes/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a note, by ID only.
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchANote.');
            }
            var localVarPath = "/v2/notes/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes: function (associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/notes.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (associatedWithType !== undefined) {
                localVarQueryParameter['associated_with_type'] = associatedWithType;
            }
            if (associatedWithId !== undefined) {
                localVarQueryParameter['associated_with_id'] = associatedWithId;
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com.
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote: function (id, content, callId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateANote.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content', 'Required parameter content was null or undefined when calling updateANote.');
            }
            var localVarPath = "/v2/notes/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (content !== undefined) {
                localVarFormParams.set('content', content);
            }
            if (callId !== undefined) {
                localVarFormParams.set('call_id', callId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotesApi - functional programming interface
 * @export
 */
exports.NotesApiFp = function (configuration) {
    return {
        /**
         * Creates a note.
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote: function (content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options) {
            var localVarFetchArgs = exports.NotesApiFetchParamCreator(configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote: function (id, options) {
            var localVarFetchArgs = exports.NotesApiFetchParamCreator(configuration).deleteANote(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a note, by ID only.
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote: function (id, options) {
            var localVarFetchArgs = exports.NotesApiFetchParamCreator(configuration).fetchANote(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes: function (associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.NotesApiFetchParamCreator(configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com.
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote: function (id, content, callId, options) {
            var localVarFetchArgs = exports.NotesApiFetchParamCreator(configuration).updateANote(id, content, callId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * NotesApi - factory interface
 * @export
 */
exports.NotesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a note.
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote: function (content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options) {
            return exports.NotesApiFp(configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options)(fetch, basePath);
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote: function (id, options) {
            return exports.NotesApiFp(configuration).deleteANote(id, options)(fetch, basePath);
        },
        /**
         * Fetches a note, by ID only.
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote: function (id, options) {
            return exports.NotesApiFp(configuration).fetchANote(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes: function (associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.NotesApiFp(configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com.
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote: function (id, content, callId, options) {
            return exports.NotesApiFp(configuration).updateANote(id, content, callId, options)(fetch, basePath);
        },
    };
};
/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
var NotesApi = /** @class */ (function (_super) {
    __extends(NotesApi, _super);
    function NotesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a note.
     * @summary Create a note
     * @param {string} content The content of the note
     * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
     * @param {number} associatedWithId ID of the item with which the note is associated
     * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
     * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
     * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
     * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    NotesApi.prototype.createANote = function (content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options) {
        return exports.NotesApiFp(this.configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
     * @summary Delete a note
     * @param {string} id Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    NotesApi.prototype.deleteANote = function (id, options) {
        return exports.NotesApiFp(this.configuration).deleteANote(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a note, by ID only.
     * @summary Fetch a note
     * @param {string} id Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    NotesApi.prototype.fetchANote = function (id, options) {
        return exports.NotesApiFp(this.configuration).fetchANote(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List notes
     * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
     * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    NotesApi.prototype.listNotes = function (associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.NotesApiFp(this.configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com.
     * @summary Update a note
     * @param {string} id Note ID
     * @param {string} content The content of the note
     * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    NotesApi.prototype.updateANote = function (id, content, callId, options) {
        return exports.NotesApiFp(this.configuration).updateANote(id, content, callId, options)(this.fetch, this.basePath);
    };
    return NotesApi;
}(BaseAPI));
exports.NotesApi = NotesApi;
/**
 * OngoingActionsApi - fetch parameter creator
 * @export
 */
exports.OngoingActionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity.
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction: function (actionId, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/ongoing_actions.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OngoingActionsApi - functional programming interface
 * @export
 */
exports.OngoingActionsApiFp = function (configuration) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity.
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction: function (actionId, options) {
            var localVarFetchArgs = exports.OngoingActionsApiFetchParamCreator(configuration).createAnOngoingAction(actionId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * OngoingActionsApi - factory interface
 * @export
 */
exports.OngoingActionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity.
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction: function (actionId, options) {
            return exports.OngoingActionsApiFp(configuration).createAnOngoingAction(actionId, options)(fetch, basePath);
        },
    };
};
/**
 * OngoingActionsApi - object-oriented interface
 * @export
 * @class OngoingActionsApi
 * @extends {BaseAPI}
 */
var OngoingActionsApi = /** @class */ (function (_super) {
    __extends(OngoingActionsApi, _super);
    function OngoingActionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity.
     * @summary Create an ongoing action
     * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OngoingActionsApi
     */
    OngoingActionsApi.prototype.createAnOngoingAction = function (actionId, options) {
        return exports.OngoingActionsApiFp(this.configuration).createAnOngoingAction(actionId, options)(this.fetch, this.basePath);
    };
    return OngoingActionsApi;
}(BaseAPI));
exports.OngoingActionsApi = OngoingActionsApi;
/**
 * PeopleApi - fetch parameter creator
 * @export
 */
exports.PeopleApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team.
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson: function (emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/people.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (emailAddress !== undefined) {
                localVarFormParams.set('email_address', emailAddress);
            }
            if (secondaryEmailAddress !== undefined) {
                localVarFormParams.set('secondary_email_address', secondaryEmailAddress);
            }
            if (personalEmailAddress !== undefined) {
                localVarFormParams.set('personal_email_address', personalEmailAddress);
            }
            if (firstName !== undefined) {
                localVarFormParams.set('first_name', firstName);
            }
            if (lastName !== undefined) {
                localVarFormParams.set('last_name', lastName);
            }
            if (phone !== undefined) {
                localVarFormParams.set('phone', phone);
            }
            if (phoneExtension !== undefined) {
                localVarFormParams.set('phone_extension', phoneExtension);
            }
            if (mobilePhone !== undefined) {
                localVarFormParams.set('mobile_phone', mobilePhone);
            }
            if (homePhone !== undefined) {
                localVarFormParams.set('home_phone', homePhone);
            }
            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl);
            }
            if (title !== undefined) {
                localVarFormParams.set('title', title);
            }
            if (city !== undefined) {
                localVarFormParams.set('city', city);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (country !== undefined) {
                localVarFormParams.set('country', country);
            }
            if (workCity !== undefined) {
                localVarFormParams.set('work_city', workCity);
            }
            if (workState !== undefined) {
                localVarFormParams.set('work_state', workState);
            }
            if (workCountry !== undefined) {
                localVarFormParams.set('work_country', workCountry);
            }
            if (personCompanyName !== undefined) {
                localVarFormParams.set('person_company_name', personCompanyName);
            }
            if (personCompanyWebsite !== undefined) {
                localVarFormParams.set('person_company_website', personCompanyWebsite);
            }
            if (personCompanyIndustry !== undefined) {
                localVarFormParams.set('person_company_industry', personCompanyIndustry);
            }
            if (jobSeniority !== undefined) {
                localVarFormParams.set('job_seniority', jobSeniority);
            }
            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact);
            }
            if (locale !== undefined) {
                localVarFormParams.set('locale', locale);
            }
            if (personalWebsite !== undefined) {
                localVarFormParams.set('personal_website', personalWebsite);
            }
            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle);
            }
            if (tags) {
                localVarFormParams.set('tags', tags.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (contactRestrictions) {
                localVarFormParams.set('contact_restrictions', contactRestrictions.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (customFields) {
                localVarFormParams.set('custom_fields', customFields.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (accountId !== undefined) {
                localVarFormParams.set('account_id', accountId);
            }
            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId);
            }
            if (importId !== undefined) {
                localVarFormParams.set('import_id', importId);
            }
            if (personStageId !== undefined) {
                localVarFormParams.set('person_stage_id', personStageId);
            }
            if (autotagDate !== undefined) {
                localVarFormParams.set('autotag_date', autotagDate);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteAPerson.');
            }
            var localVarPath = "/v2/people/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a person, by ID only.
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAPerson.');
            }
            var localVarPath = "/v2/people/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople: function (ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/people.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (emailAddresses) {
                localVarQueryParameter['email_addresses'] = emailAddresses.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (ownedByGuid) {
                localVarQueryParameter['owned_by_guid'] = ownedByGuid.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (personStageId) {
                localVarQueryParameter['person_stage_id'] = personStageId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (crmId) {
                localVarQueryParameter['crm_id'] = crmId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (doNotContact !== undefined) {
                localVarQueryParameter['do_not_contact'] = doNotContact;
            }
            if (canEmail !== undefined) {
                localVarQueryParameter['can_email'] = canEmail;
            }
            if (canCall !== undefined) {
                localVarQueryParameter['can_call'] = canCall;
            }
            if (accountId) {
                localVarQueryParameter['account_id'] = accountId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person.
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson: function (id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateAPerson.');
            }
            var localVarPath = "/v2/people/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (emailAddress !== undefined) {
                localVarFormParams.set('email_address', emailAddress);
            }
            if (secondaryEmailAddress !== undefined) {
                localVarFormParams.set('secondary_email_address', secondaryEmailAddress);
            }
            if (personalEmailAddress !== undefined) {
                localVarFormParams.set('personal_email_address', personalEmailAddress);
            }
            if (firstName !== undefined) {
                localVarFormParams.set('first_name', firstName);
            }
            if (lastName !== undefined) {
                localVarFormParams.set('last_name', lastName);
            }
            if (phone !== undefined) {
                localVarFormParams.set('phone', phone);
            }
            if (phoneExtension !== undefined) {
                localVarFormParams.set('phone_extension', phoneExtension);
            }
            if (mobilePhone !== undefined) {
                localVarFormParams.set('mobile_phone', mobilePhone);
            }
            if (homePhone !== undefined) {
                localVarFormParams.set('home_phone', homePhone);
            }
            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl);
            }
            if (title !== undefined) {
                localVarFormParams.set('title', title);
            }
            if (city !== undefined) {
                localVarFormParams.set('city', city);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (country !== undefined) {
                localVarFormParams.set('country', country);
            }
            if (workCity !== undefined) {
                localVarFormParams.set('work_city', workCity);
            }
            if (workState !== undefined) {
                localVarFormParams.set('work_state', workState);
            }
            if (workCountry !== undefined) {
                localVarFormParams.set('work_country', workCountry);
            }
            if (personCompanyName !== undefined) {
                localVarFormParams.set('person_company_name', personCompanyName);
            }
            if (personCompanyWebsite !== undefined) {
                localVarFormParams.set('person_company_website', personCompanyWebsite);
            }
            if (personCompanyIndustry !== undefined) {
                localVarFormParams.set('person_company_industry', personCompanyIndustry);
            }
            if (jobSeniority !== undefined) {
                localVarFormParams.set('job_seniority', jobSeniority);
            }
            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact);
            }
            if (locale !== undefined) {
                localVarFormParams.set('locale', locale);
            }
            if (personalWebsite !== undefined) {
                localVarFormParams.set('personal_website', personalWebsite);
            }
            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle);
            }
            if (tags) {
                localVarFormParams.set('tags', tags.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (contactRestrictions) {
                localVarFormParams.set('contact_restrictions', contactRestrictions.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (customFields) {
                localVarFormParams.set('custom_fields', customFields.join(exports.COLLECTION_FORMATS["csv"]));
            }
            if (accountId !== undefined) {
                localVarFormParams.set('account_id', accountId);
            }
            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId);
            }
            if (importId !== undefined) {
                localVarFormParams.set('import_id', importId);
            }
            if (personStageId !== undefined) {
                localVarFormParams.set('person_stage_id', personStageId);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PeopleApi - functional programming interface
 * @export
 */
exports.PeopleApiFp = function (configuration) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team.
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson: function (emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options) {
            var localVarFetchArgs = exports.PeopleApiFetchParamCreator(configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson: function (id, options) {
            var localVarFetchArgs = exports.PeopleApiFetchParamCreator(configuration).deleteAPerson(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a person, by ID only.
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson: function (id, options) {
            var localVarFetchArgs = exports.PeopleApiFetchParamCreator(configuration).fetchAPerson(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople: function (ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.PeopleApiFetchParamCreator(configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a person.
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson: function (id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options) {
            var localVarFetchArgs = exports.PeopleApiFetchParamCreator(configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * PeopleApi - factory interface
 * @export
 */
exports.PeopleApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team.
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson: function (emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options) {
            return exports.PeopleApiFp(configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options)(fetch, basePath);
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson: function (id, options) {
            return exports.PeopleApiFp(configuration).deleteAPerson(id, options)(fetch, basePath);
        },
        /**
         * Fetches a person, by ID only.
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson: function (id, options) {
            return exports.PeopleApiFp(configuration).fetchAPerson(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople: function (ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.PeopleApiFp(configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a person.
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson: function (id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options) {
            return exports.PeopleApiFp(configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options)(fetch, basePath);
        },
    };
};
/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
var PeopleApi = /** @class */ (function (_super) {
    __extends(PeopleApi, _super);
    function PeopleApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team.
     * @summary Create a person
     * @param {string} [emailAddress] Email address
     * @param {string} [secondaryEmailAddress] Alternate email address
     * @param {string} [personalEmailAddress] Personal email address
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [phone] Phone without formatting
     * @param {string} [phoneExtension] Phone extension without formatting
     * @param {string} [mobilePhone] Mobile phone without formatting
     * @param {string} [homePhone] Home phone without formatting
     * @param {string} [linkedinUrl] Linkedin URL
     * @param {string} [title] Job title
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [country] Country
     * @param {string} [workCity] Work location - city
     * @param {string} [workState] Work location - state
     * @param {string} [workCountry] Work location - country
     * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
     * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
     * @param {string} [locale] Time locale of the person
     * @param {string} [personalWebsite] The website of this person
     * @param {string} [twitterHandle] The twitter handle of this person
     * @param {Array<string>} [tags] All tags applied to this person
     * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {number} [accountId] ID of the Account to link this person to
     * @param {number} [ownerId] ID of the User that owns this person
     * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
     * @param {number} [personStageId] ID of the PersonStage of this person
     * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    PeopleApi.prototype.createAPerson = function (emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options) {
        return exports.PeopleApiFp(this.configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
     * @summary Delete a person
     * @param {string} id Person id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    PeopleApi.prototype.deleteAPerson = function (id, options) {
        return exports.PeopleApiFp(this.configuration).deleteAPerson(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a person, by ID only.
     * @summary Fetch a person
     * @param {string} id Person ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    PeopleApi.prototype.fetchAPerson = function (id, options) {
        return exports.PeopleApiFp(this.configuration).fetchAPerson(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List people
     * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
     * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
     * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
     * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
     * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
     * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
     * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
     * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    PeopleApi.prototype.listPeople = function (ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.PeopleApiFp(this.configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates a person.
     * @summary Update a person
     * @param {string} id Person id
     * @param {string} [emailAddress] Email address
     * @param {string} [secondaryEmailAddress] Alternate email address
     * @param {string} [personalEmailAddress] Personal email address
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [phone] Phone without formatting
     * @param {string} [phoneExtension] Phone extension without formatting
     * @param {string} [mobilePhone] Mobile phone without formatting
     * @param {string} [homePhone] Home phone without formatting
     * @param {string} [linkedinUrl] Linkedin URL
     * @param {string} [title] Job title
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [country] Country
     * @param {string} [workCity] Work location - city
     * @param {string} [workState] Work location - state
     * @param {string} [workCountry] Work location - country
     * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
     * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
     * @param {string} [locale] Time locale of the person
     * @param {string} [personalWebsite] The website of this person
     * @param {string} [twitterHandle] The twitter handle of this person
     * @param {Array<string>} [tags] All tags applied to this person
     * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {number} [accountId] ID of the Account to link this person to
     * @param {number} [ownerId] ID of the User that owns this person
     * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
     * @param {number} [personStageId] ID of the PersonStage of this person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    PeopleApi.prototype.updateAPerson = function (id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options) {
        return exports.PeopleApiFp(this.configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options)(this.fetch, this.basePath);
    };
    return PeopleApi;
}(BaseAPI));
exports.PeopleApi = PeopleApi;
/**
 * PersonStagesApi - fetch parameter creator
 * @export
 */
exports.PersonStagesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a person stage.
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage: function (name, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling createAPersonStage.');
            }
            var localVarPath = "/v2/person_stages.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteAnPersonStage.');
            }
            var localVarPath = "/v2/person_stages/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a person stage, by ID only.
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAPersonStage.');
            }
            var localVarPath = "/v2/person_stages/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/person_stages.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person stage.
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage: function (id, name, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateAPersonStage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling updateAPersonStage.');
            }
            var localVarPath = "/v2/person_stages/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PersonStagesApi - functional programming interface
 * @export
 */
exports.PersonStagesApiFp = function (configuration) {
    return {
        /**
         * Creates a person stage.
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage: function (name, options) {
            var localVarFetchArgs = exports.PersonStagesApiFetchParamCreator(configuration).createAPersonStage(name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage: function (id, options) {
            var localVarFetchArgs = exports.PersonStagesApiFetchParamCreator(configuration).deleteAnPersonStage(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a person stage, by ID only.
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage: function (id, options) {
            var localVarFetchArgs = exports.PersonStagesApiFetchParamCreator(configuration).fetchAPersonStage(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.PersonStagesApiFetchParamCreator(configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a person stage.
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage: function (id, name, options) {
            var localVarFetchArgs = exports.PersonStagesApiFetchParamCreator(configuration).updateAPersonStage(id, name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * PersonStagesApi - factory interface
 * @export
 */
exports.PersonStagesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a person stage.
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage: function (name, options) {
            return exports.PersonStagesApiFp(configuration).createAPersonStage(name, options)(fetch, basePath);
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage: function (id, options) {
            return exports.PersonStagesApiFp(configuration).deleteAnPersonStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches a person stage, by ID only.
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage: function (id, options) {
            return exports.PersonStagesApiFp(configuration).fetchAPersonStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.PersonStagesApiFp(configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a person stage.
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage: function (id, name, options) {
            return exports.PersonStagesApiFp(configuration).updateAPersonStage(id, name, options)(fetch, basePath);
        },
    };
};
/**
 * PersonStagesApi - object-oriented interface
 * @export
 * @class PersonStagesApi
 * @extends {BaseAPI}
 */
var PersonStagesApi = /** @class */ (function (_super) {
    __extends(PersonStagesApi, _super);
    function PersonStagesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a person stage.
     * @summary Create a person stage
     * @param {string} name The name of the new stage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    PersonStagesApi.prototype.createAPersonStage = function (name, options) {
        return exports.PersonStagesApiFp(this.configuration).createAPersonStage(name, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
     * @summary Delete an person stage
     * @param {string} id Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    PersonStagesApi.prototype.deleteAnPersonStage = function (id, options) {
        return exports.PersonStagesApiFp(this.configuration).deleteAnPersonStage(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a person stage, by ID only.
     * @summary Fetch a person stage
     * @param {string} id Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    PersonStagesApi.prototype.fetchAPersonStage = function (id, options) {
        return exports.PersonStagesApiFp(this.configuration).fetchAPersonStage(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List person stages
     * @param {Array<number>} [ids] IDs of person stages to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    PersonStagesApi.prototype.listPersonStages = function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.PersonStagesApiFp(this.configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates a person stage.
     * @summary Update a person stage
     * @param {string} id Stage ID
     * @param {string} name The name of the stage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    PersonStagesApi.prototype.updateAPersonStage = function (id, name, options) {
        return exports.PersonStagesApiFp(this.configuration).updateAPersonStage(id, name, options)(this.fetch, this.basePath);
    };
    return PersonStagesApi;
}(BaseAPI));
exports.PersonStagesApi = PersonStagesApi;
/**
 * PhoneNumberAssignmentsApi - fetch parameter creator
 * @export
 */
exports.PhoneNumberAssignmentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a phone number assignment, by ID only.
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAPhoneNumberAssignment.');
            }
            var localVarPath = "/v2/phone_number_assignments/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/phone_number_assignments.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PhoneNumberAssignmentsApi - functional programming interface
 * @export
 */
exports.PhoneNumberAssignmentsApiFp = function (configuration) {
    return {
        /**
         * Fetches a phone number assignment, by ID only.
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment: function (id, options) {
            var localVarFetchArgs = exports.PhoneNumberAssignmentsApiFetchParamCreator(configuration).fetchAPhoneNumberAssignment(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.PhoneNumberAssignmentsApiFetchParamCreator(configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * PhoneNumberAssignmentsApi - factory interface
 * @export
 */
exports.PhoneNumberAssignmentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a phone number assignment, by ID only.
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment: function (id, options) {
            return exports.PhoneNumberAssignmentsApiFp(configuration).fetchAPhoneNumberAssignment(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments: function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.PhoneNumberAssignmentsApiFp(configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * PhoneNumberAssignmentsApi - object-oriented interface
 * @export
 * @class PhoneNumberAssignmentsApi
 * @extends {BaseAPI}
 */
var PhoneNumberAssignmentsApi = /** @class */ (function (_super) {
    __extends(PhoneNumberAssignmentsApi, _super);
    function PhoneNumberAssignmentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a phone number assignment, by ID only.
     * @summary Fetch a phone number assignment
     * @param {string} id PhoneNumberAssignment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneNumberAssignmentsApi
     */
    PhoneNumberAssignmentsApi.prototype.fetchAPhoneNumberAssignment = function (id, options) {
        return exports.PhoneNumberAssignmentsApiFp(this.configuration).fetchAPhoneNumberAssignment(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List phone number assignments
     * @param {Array<number>} [ids] IDs of phone number assignments to fetch
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneNumberAssignmentsApi
     */
    PhoneNumberAssignmentsApi.prototype.listPhoneNumberAssignments = function (ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.PhoneNumberAssignmentsApiFp(this.configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return PhoneNumberAssignmentsApi;
}(BaseAPI));
exports.PhoneNumberAssignmentsApi = PhoneNumberAssignmentsApi;
/**
 * RecordingSettingsApi - fetch parameter creator
 * @export
 */
exports.RecordingSettingsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format.
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchRecordingSetting.');
            }
            var localVarPath = "/v2/phone_numbers/recording_settings/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RecordingSettingsApi - functional programming interface
 * @export
 */
exports.RecordingSettingsApiFp = function (configuration) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format.
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting: function (id, options) {
            var localVarFetchArgs = exports.RecordingSettingsApiFetchParamCreator(configuration).fetchRecordingSetting(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * RecordingSettingsApi - factory interface
 * @export
 */
exports.RecordingSettingsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format.
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting: function (id, options) {
            return exports.RecordingSettingsApiFp(configuration).fetchRecordingSetting(id, options)(fetch, basePath);
        },
    };
};
/**
 * RecordingSettingsApi - object-oriented interface
 * @export
 * @class RecordingSettingsApi
 * @extends {BaseAPI}
 */
var RecordingSettingsApi = /** @class */ (function (_super) {
    __extends(RecordingSettingsApi, _super);
    function RecordingSettingsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format.
     * @summary Fetch recording setting
     * @param {string} id E.164 Phone Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingSettingsApi
     */
    RecordingSettingsApi.prototype.fetchRecordingSetting = function (id, options) {
        return exports.RecordingSettingsApiFp(this.configuration).fetchRecordingSetting(id, options)(this.fetch, this.basePath);
    };
    return RecordingSettingsApi;
}(BaseAPI));
exports.RecordingSettingsApi = RecordingSettingsApi;
/**
 * SavedListViewsApi - fetch parameter creator
 * @export
 */
exports.SavedListViewsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a saved list view.
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView: function (name, view, isDefault, viewParams, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling createASavedListView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view', 'Required parameter view was null or undefined when calling createASavedListView.');
            }
            var localVarPath = "/v2/saved_list_views.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (view !== undefined) {
                localVarFormParams.set('view', view);
            }
            if (isDefault !== undefined) {
                localVarFormParams.set('is_default', isDefault);
            }
            if (viewParams !== undefined) {
                localVarFormParams.set('view_params', viewParams);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteASavedListView.');
            }
            var localVarPath = "/v2/saved_list_views/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a saved list view, by ID only.
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchASavedListView.');
            }
            var localVarPath = "/v2/saved_list_views/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews: function (ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/saved_list_views.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a saved list view.
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView: function (id, name, isDefault, viewParams, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateASavedListView.');
            }
            var localVarPath = "/v2/saved_list_views/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            if (name !== undefined) {
                localVarFormParams.set('name', name);
            }
            if (isDefault !== undefined) {
                localVarFormParams.set('is_default', isDefault);
            }
            if (viewParams !== undefined) {
                localVarFormParams.set('view_params', viewParams);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SavedListViewsApi - functional programming interface
 * @export
 */
exports.SavedListViewsApiFp = function (configuration) {
    return {
        /**
         * Creates a saved list view.
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView: function (name, view, isDefault, viewParams, options) {
            var localVarFetchArgs = exports.SavedListViewsApiFetchParamCreator(configuration).createASavedListView(name, view, isDefault, viewParams, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView: function (id, options) {
            var localVarFetchArgs = exports.SavedListViewsApiFetchParamCreator(configuration).deleteASavedListView(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a saved list view, by ID only.
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView: function (id, options) {
            var localVarFetchArgs = exports.SavedListViewsApiFetchParamCreator(configuration).fetchASavedListView(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews: function (ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.SavedListViewsApiFetchParamCreator(configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a saved list view.
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView: function (id, name, isDefault, viewParams, options) {
            var localVarFetchArgs = exports.SavedListViewsApiFetchParamCreator(configuration).updateASavedListView(id, name, isDefault, viewParams, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SavedListViewsApi - factory interface
 * @export
 */
exports.SavedListViewsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a saved list view.
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView: function (name, view, isDefault, viewParams, options) {
            return exports.SavedListViewsApiFp(configuration).createASavedListView(name, view, isDefault, viewParams, options)(fetch, basePath);
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView: function (id, options) {
            return exports.SavedListViewsApiFp(configuration).deleteASavedListView(id, options)(fetch, basePath);
        },
        /**
         * Fetches a saved list view, by ID only.
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView: function (id, options) {
            return exports.SavedListViewsApiFp(configuration).fetchASavedListView(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews: function (ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.SavedListViewsApiFp(configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a saved list view.
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView: function (id, name, isDefault, viewParams, options) {
            return exports.SavedListViewsApiFp(configuration).updateASavedListView(id, name, isDefault, viewParams, options)(fetch, basePath);
        },
    };
};
/**
 * SavedListViewsApi - object-oriented interface
 * @export
 * @class SavedListViewsApi
 * @extends {BaseAPI}
 */
var SavedListViewsApi = /** @class */ (function (_super) {
    __extends(SavedListViewsApi, _super);
    function SavedListViewsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a saved list view.
     * @summary Create a saved list view
     * @param {string} name The name of the saved list view
     * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
     * @param {boolean} [isDefault] Whether the saved list view is the default
     * @param {string} [viewParams] JSON object of list view parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    SavedListViewsApi.prototype.createASavedListView = function (name, view, isDefault, viewParams, options) {
        return exports.SavedListViewsApiFp(this.configuration).createASavedListView(name, view, isDefault, viewParams, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully.
     * @summary Delete a saved list view
     * @param {string} id Saved List View ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    SavedListViewsApi.prototype.deleteASavedListView = function (id, options) {
        return exports.SavedListViewsApiFp(this.configuration).deleteASavedListView(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches a saved list view, by ID only.
     * @summary Fetch a saved list view
     * @param {string} id Saved List View ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    SavedListViewsApi.prototype.fetchASavedListView = function (id, options) {
        return exports.SavedListViewsApiFp(this.configuration).fetchASavedListView(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List saved list views
     * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {string} [view] Type of saved list views to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    SavedListViewsApi.prototype.listSavedListViews = function (ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.SavedListViewsApiFp(this.configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    /**
     * Updates a saved list view.
     * @summary Update a saved list view
     * @param {string} id Saved List View ID
     * @param {string} [name] The name of the saved list view
     * @param {boolean} [isDefault] Whether the saved list view is the default
     * @param {string} [viewParams] JSON object of list view parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    SavedListViewsApi.prototype.updateASavedListView = function (id, name, isDefault, viewParams, options) {
        return exports.SavedListViewsApiFp(this.configuration).updateASavedListView(id, name, isDefault, viewParams, options)(this.fetch, this.basePath);
    };
    return SavedListViewsApi;
}(BaseAPI));
exports.SavedListViewsApi = SavedListViewsApi;
/**
 * StepsApi - fetch parameter creator
 * @export
 */
exports.StepsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a step, by ID only.
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAStep.');
            }
            var localVarPath = "/v2/steps/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: function (ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/steps.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (hasDueActions !== undefined) {
                localVarQueryParameter['has_due_actions'] = hasDueActions;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StepsApi - functional programming interface
 * @export
 */
exports.StepsApiFp = function (configuration) {
    return {
        /**
         * Fetches a step, by ID only.
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep: function (id, options) {
            var localVarFetchArgs = exports.StepsApiFetchParamCreator(configuration).fetchAStep(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: function (ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.StepsApiFetchParamCreator(configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * StepsApi - factory interface
 * @export
 */
exports.StepsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a step, by ID only.
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep: function (id, options) {
            return exports.StepsApiFp(configuration).fetchAStep(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: function (ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.StepsApiFp(configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * StepsApi - object-oriented interface
 * @export
 * @class StepsApi
 * @extends {BaseAPI}
 */
var StepsApi = /** @class */ (function (_super) {
    __extends(StepsApi, _super);
    function StepsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a step, by ID only.
     * @summary Fetch a step
     * @param {string} id Step ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApi
     */
    StepsApi.prototype.fetchAStep = function (id, options) {
        return exports.StepsApiFp(this.configuration).fetchAStep(id, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List steps
     * @param {Array<number>} [ids] IDs of steps to fetch.
     * @param {number} [cadenceId] Filter by cadence ID
     * @param {string} [type] Filter by step type
     * @param {boolean} [hasDueActions] Filter by whether a step has due actions
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApi
     */
    StepsApi.prototype.listSteps = function (ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.StepsApiFp(this.configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return StepsApi;
}(BaseAPI));
exports.StepsApi = StepsApi;
/**
 * SuccessesApi - fetch parameter creator
 * @export
 */
exports.SuccessesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses: function (ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/successes.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (personId) {
                localVarQueryParameter['person_id'] = personId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SuccessesApi - functional programming interface
 * @export
 */
exports.SuccessesApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses: function (ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.SuccessesApiFetchParamCreator(configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SuccessesApi - factory interface
 * @export
 */
exports.SuccessesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters.
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses: function (ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.SuccessesApiFp(configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * SuccessesApi - object-oriented interface
 * @export
 * @class SuccessesApi
 * @extends {BaseAPI}
 */
var SuccessesApi = /** @class */ (function (_super) {
    __extends(SuccessesApi, _super);
    function SuccessesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters.
     * @summary List successes
     * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuccessesApi
     */
    SuccessesApi.prototype.listSuccesses = function (ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.SuccessesApiFp(this.configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return SuccessesApi;
}(BaseAPI));
exports.SuccessesApi = SuccessesApi;
/**
 * TagsApi - fetch parameter creator
 * @export
 */
exports.TagsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types.
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags: function (search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/tags.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TagsApi - functional programming interface
 * @export
 */
exports.TagsApiFp = function (configuration) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types.
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags: function (search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.TagsApiFetchParamCreator(configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TagsApi - factory interface
 * @export
 */
exports.TagsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types.
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags: function (search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.TagsApiFp(configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
var TagsApi = /** @class */ (function (_super) {
    __extends(TagsApi, _super);
    function TagsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types.
     * @summary List team tags
     * @param {string} [search] Filters tags by name
     * @param {Array<number>} [ids] Filters tags by their IDs
     * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    TagsApi.prototype.listTeamTags = function (search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.TagsApiFp(this.configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return TagsApi;
}(BaseAPI));
exports.TagsApi = TagsApi;
/**
 * TeamApi - fetch parameter creator
 * @export
 */
exports.TeamApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches the team of the authenticated user.
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/team.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TeamApi - functional programming interface
 * @export
 */
exports.TeamApiFp = function (configuration) {
    return {
        /**
         * Fetches the team of the authenticated user.
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam: function (options) {
            var localVarFetchArgs = exports.TeamApiFetchParamCreator(configuration).fetchCurrentTeam(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TeamApi - factory interface
 * @export
 */
exports.TeamApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches the team of the authenticated user.
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam: function (options) {
            return exports.TeamApiFp(configuration).fetchCurrentTeam(options)(fetch, basePath);
        },
    };
};
/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
var TeamApi = /** @class */ (function (_super) {
    __extends(TeamApi, _super);
    function TeamApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches the team of the authenticated user.
     * @summary Fetch current team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    TeamApi.prototype.fetchCurrentTeam = function (options) {
        return exports.TeamApiFp(this.configuration).fetchCurrentTeam(options)(this.fetch, this.basePath);
    };
    return TeamApi;
}(BaseAPI));
exports.TeamApi = TeamApi;
/**
 * TeamTemplateAttachmentsApi - fetch parameter creator
 * @export
 */
exports.TeamTemplateAttachmentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments: function (ids, teamTemplateId, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/team_template_attachments.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (teamTemplateId) {
                localVarQueryParameter['team_template_id'] = teamTemplateId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TeamTemplateAttachmentsApi - functional programming interface
 * @export
 */
exports.TeamTemplateAttachmentsApiFp = function (configuration) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments: function (ids, teamTemplateId, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.TeamTemplateAttachmentsApiFetchParamCreator(configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TeamTemplateAttachmentsApi - factory interface
 * @export
 */
exports.TeamTemplateAttachmentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters.
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments: function (ids, teamTemplateId, perPage, page, includePagingCounts, options) {
            return exports.TeamTemplateAttachmentsApiFp(configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * TeamTemplateAttachmentsApi - object-oriented interface
 * @export
 * @class TeamTemplateAttachmentsApi
 * @extends {BaseAPI}
 */
var TeamTemplateAttachmentsApi = /** @class */ (function (_super) {
    __extends(TeamTemplateAttachmentsApi, _super);
    function TeamTemplateAttachmentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters.
     * @summary List team template attachments
     * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplateAttachmentsApi
     */
    TeamTemplateAttachmentsApi.prototype.listTeamTemplateAttachments = function (ids, teamTemplateId, perPage, page, includePagingCounts, options) {
        return exports.TeamTemplateAttachmentsApiFp(this.configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return TeamTemplateAttachmentsApi;
}(BaseAPI));
exports.TeamTemplateAttachmentsApi = TeamTemplateAttachmentsApi;
/**
 * TeamTemplatesApi - fetch parameter creator
 * @export
 */
exports.TeamTemplatesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a team template, by ID only.
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate: function (id, includeSignature, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchATeamTemplate.');
            }
            var localVarPath = "/v2/team_templates/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (includeSignature !== undefined) {
                localVarQueryParameter['include_signature'] = includeSignature;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint.
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates: function (ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/team_templates.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (ids) {
                localVarQueryParameter['ids'] = ids.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (includeArchivedTemplates !== undefined) {
                localVarQueryParameter['include_archived_templates'] = includeArchivedTemplates;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TeamTemplatesApi - functional programming interface
 * @export
 */
exports.TeamTemplatesApiFp = function (configuration) {
    return {
        /**
         * Fetches a team template, by ID only.
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate: function (id, includeSignature, options) {
            var localVarFetchArgs = exports.TeamTemplatesApiFetchParamCreator(configuration).fetchATeamTemplate(id, includeSignature, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint.
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates: function (ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            var localVarFetchArgs = exports.TeamTemplatesApiFetchParamCreator(configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TeamTemplatesApi - factory interface
 * @export
 */
exports.TeamTemplatesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a team template, by ID only.
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate: function (id, includeSignature, options) {
            return exports.TeamTemplatesApiFp(configuration).fetchATeamTemplate(id, includeSignature, options)(fetch, basePath);
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint.
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates: function (ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
            return exports.TeamTemplatesApiFp(configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};
/**
 * TeamTemplatesApi - object-oriented interface
 * @export
 * @class TeamTemplatesApi
 * @extends {BaseAPI}
 */
var TeamTemplatesApi = /** @class */ (function (_super) {
    __extends(TeamTemplatesApi, _super);
    function TeamTemplatesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a team template, by ID only.
     * @summary Fetch a team template
     * @param {string} id Team Template ID
     * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplatesApi
     */
    TeamTemplatesApi.prototype.fetchATeamTemplate = function (id, includeSignature, options) {
        return exports.TeamTemplatesApiFp(this.configuration).fetchATeamTemplate(id, includeSignature, options)(this.fetch, this.basePath);
    };
    /**
     * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint.
     * @summary List team templates
     * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]}
     * @param {string} [search] Filters email templates by title or subject
     * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
     * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
     * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplatesApi
     */
    TeamTemplatesApi.prototype.listTeamTemplates = function (ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options) {
        return exports.TeamTemplatesApiFp(this.configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    };
    return TeamTemplatesApi;
}(BaseAPI));
exports.TeamTemplatesApi = TeamTemplatesApi;
/**
 * UsersApi - fetch parameter creator
 * @export
 */
exports.UsersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetches a user, by ID only.
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fetchAUser.');
            }
            var localVarPath = "/v2/users/{id}.json"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: function (guid, groupId, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/v2/users.json";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (guid) {
                localVarQueryParameter['guid'] = guid.join(exports.COLLECTION_FORMATS["csv"]);
            }
            if (groupId) {
                localVarQueryParameter['group_id'] = groupId.join(exports.COLLECTION_FORMATS["csv"]);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
exports.UsersApiFp = function (configuration) {
    return {
        /**
         * Fetches a user, by ID only.
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser: function (id, options) {
            var localVarFetchArgs = exports.UsersApiFetchParamCreator(configuration).fetchAUser(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: function (guid, groupId, options) {
            var localVarFetchArgs = exports.UsersApiFetchParamCreator(configuration).listUsers(guid, groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
exports.UsersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetches a user, by ID only.
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser: function (id, options) {
            return exports.UsersApiFp(configuration).fetchAUser(id, options)(fetch, basePath);
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: function (guid, groupId, options) {
            return exports.UsersApiFp(configuration).listUsers(guid, groupId, options)(fetch, basePath);
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
var UsersApi = /** @class */ (function (_super) {
    __extends(UsersApi, _super);
    function UsersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a user, by ID only.
     * @summary Fetch a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.fetchAUser = function (id, options) {
        return exports.UsersApiFp(this.configuration).fetchAUser(id, options)(this.fetch, this.basePath);
    };
    /**
     * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team
     * @summary List users
     * @param {Array<string>} [guid] Filters list to only include guids
     * @param {Array<string>} [groupId] Filters users by group_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.listUsers = function (guid, groupId, options) {
        return exports.UsersApiFp(this.configuration).listUsers(guid, groupId, options)(this.fetch, this.basePath);
    };
    return UsersApi;
}(BaseAPI));
exports.UsersApi = UsersApi;
//# sourceMappingURL=api.js.map