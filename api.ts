/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SalesLoft Platform
 * SalesLoft helps transform sales teams into modern sales organizations  - converting more target accounts into customer accounts 
 *
 * OpenAPI spec version: v2
 * Contact: integrations@salesloft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.salesloft.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * ID of Account
     * @type {number}
     * @memberof Account
     */
    id?: number;
    /**
     * Datetime of when the Account was created
     * @type {string}
     * @memberof Account
     */
    createdAt?: string;
    /**
     * Datetime of when the Account was last updated
     * @type {string}
     * @memberof Account
     */
    updatedAt?: string;
    /**
     * Datetime of when the Account was archived, if archived
     * @type {string}
     * @memberof Account
     */
    archivedAt?: string;
    /**
     * Account Full Name
     * @type {string}
     * @memberof Account
     */
    name?: string;
    /**
     * Website domain, not a fully qualified URI
     * @type {string}
     * @memberof Account
     */
    domain?: string;
    /**
     * Conversational name of the Account
     * @type {string}
     * @memberof Account
     */
    conversationalName?: string;
    /**
     * Description
     * @type {string}
     * @memberof Account
     */
    description?: string;
    /**
     * Phone number without formatting
     * @type {string}
     * @memberof Account
     */
    phone?: string;
    /**
     * Website
     * @type {string}
     * @memberof Account
     */
    website?: string;
    /**
     * Full LinkedIn url
     * @type {string}
     * @memberof Account
     */
    linkedinUrl?: string;
    /**
     * Twitter handle, with @
     * @type {string}
     * @memberof Account
     */
    twitterHandle?: string;
    /**
     * Street name and number
     * @type {string}
     * @memberof Account
     */
    street?: string;
    /**
     * City
     * @type {string}
     * @memberof Account
     */
    city?: string;
    /**
     * State
     * @type {string}
     * @memberof Account
     */
    state?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof Account
     */
    postalCode?: string;
    /**
     * Country
     * @type {string}
     * @memberof Account
     */
    country?: string;
    /**
     * Time locale
     * @type {string}
     * @memberof Account
     */
    locale?: string;
    /**
     * Industry
     * @type {string}
     * @memberof Account
     */
    industry?: string;
    /**
     * Type of the Account's company
     * @type {string}
     * @memberof Account
     */
    companyType?: string;
    /**
     * Date or year of founding
     * @type {string}
     * @memberof Account
     */
    founded?: string;
    /**
     * Estimated revenue range
     * @type {string}
     * @memberof Account
     */
    revenueRange?: string;
    /**
     * Estimated number of people in employment
     * @type {string}
     * @memberof Account
     */
    size?: string;
    /**
     * CRM ID, currently Salesforce.com only
     * @type {string}
     * @memberof Account
     */
    crmId?: string;
    /**
     * CRM url, currently Salesforce.com only
     * @type {string}
     * @memberof Account
     */
    crmUrl?: string;
    /**
     * CRM object type, currently Salesforce.com only
     * @type {string}
     * @memberof Account
     */
    crmObjectType?: string;
    /**
     * Mapped owner field from the CRM, currently Salesforce.com only
     * @type {string}
     * @memberof Account
     */
    ownerCrmId?: string;
    /**
     * Datetime this Account was last contacted
     * @type {string}
     * @memberof Account
     */
    lastContactedAt?: string;
    /**
     * The type of the last touch to this Account. Can be call, email, other
     * @type {string}
     * @memberof Account
     */
    lastContactedType?: string;
    /**
     * Whether this company has opted out of communications. Do not contact someone at this company when this is set to true
     * @type {boolean}
     * @memberof Account
     */
    doNotContact?: boolean;
    /**
     * Custom fields are defined by the user's team. Only fields with values are presented in the API.
     * @type {any}
     * @memberof Account
     */
    customFields?: any;
    /**
     * All tags applied to this Account
     * @type {Array<string>}
     * @memberof Account
     */
    tags?: Array<string>;
    /**
     * Various counts for this Account
     * @type {EmbeddedAccountCounts}
     * @memberof Account
     */
    counts?: EmbeddedAccountCounts;
    /**
     * User that is marked as the owner of this Account
     * @type {EmbeddedResource}
     * @memberof Account
     */
    owner?: EmbeddedResource;
    /**
     * User that created this Account
     * @type {EmbeddedResource}
     * @memberof Account
     */
    creator?: EmbeddedResource;
    /**
     * User that last contacted this Account
     * @type {EmbeddedResource}
     * @memberof Account
     */
    lastContactedBy?: EmbeddedResource;
    /**
     * Person who was last contacted at this Account
     * @type {EmbeddedResource}
     * @memberof Account
     */
    lastContactedPerson?: EmbeddedResource;
    /**
     * Company Stage that this Account has set. This is referred to as Account Stage in other parts of the API. When sorting by account_stage, the company stage's order is used
     * @type {EmbeddedResource}
     * @memberof Account
     */
    companyStage?: EmbeddedResource;
    /**
     * Account Tier that this Account has set
     * @type {EmbeddedResource}
     * @memberof Account
     */
    accountTier?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface AccountStage
 */
export interface AccountStage {
    /**
     * ID of Account Stage
     * @type {number}
     * @memberof AccountStage
     */
    id?: number;
    /**
     * Name of Account Stage
     * @type {string}
     * @memberof AccountStage
     */
    name?: string;
    /**
     * Datetime of when the Account Stage was created
     * @type {string}
     * @memberof AccountStage
     */
    createdAt?: string;
    /**
     * Datetime of when the Account Stage was last updated
     * @type {string}
     * @memberof AccountStage
     */
    updatedAt?: string;
    /**
     * Order of Account Stage
     * @type {number}
     * @memberof AccountStage
     */
    order?: number;
}

/**
 * 
 * @export
 * @interface AccountTier
 */
export interface AccountTier {
    /**
     * ID of Account Tier
     * @type {number}
     * @memberof AccountTier
     */
    id?: number;
    /**
     * Name of the Account Tier
     * @type {string}
     * @memberof AccountTier
     */
    name?: string;
    /**
     * The order of the account tier
     * @type {number}
     * @memberof AccountTier
     */
    order?: number;
    /**
     * Datetime of when the Account Tier was created
     * @type {string}
     * @memberof AccountTier
     */
    createdAt?: string;
    /**
     * Datetime of when the Account Tier was last updated
     * @type {string}
     * @memberof AccountTier
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * ID of Action
     * @type {number}
     * @memberof Action
     */
    id?: number;
    /**
     * Whether this step is due
     * @type {boolean}
     * @memberof Action
     */
    due?: boolean;
    /**
     * Datetime of when the Action was created
     * @type {string}
     * @memberof Action
     */
    createdAt?: string;
    /**
     * Datetime of when the Action was last updated
     * @type {string}
     * @memberof Action
     */
    updatedAt?: string;
    /**
     * The type of this action. Valid types are: email, phone, other. New types may be added in the future. 
     * @type {string}
     * @memberof Action
     */
    type?: string;
    /**
     * The current state of the person on the cadence. Possible values are:  in_progress: this action has not been completed  pending_activity: this action has been acted upon, but the action has not been completed. (i.e. the email is scheduled to send, but has not been delivered yet) 
     * @type {string}
     * @memberof Action
     */
    status?: string;
    /**
     * When action is due
     * @type {string}
     * @memberof Action
     */
    dueOn?: string;
    /**
     * The type specific action details
     * @type {EmbeddedResource}
     * @memberof Action
     */
    actionDetails?: EmbeddedResource;
    /**
     * User assigned to action
     * @type {EmbeddedResource}
     * @memberof Action
     */
    user?: EmbeddedResource;
    /**
     * The subject of an action
     * @type {EmbeddedResource}
     * @memberof Action
     */
    person?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * Datetime of when the Activity was last updated
     * @type {string}
     * @memberof Activity
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface Cadence
 */
export interface Cadence {
    /**
     * ID of cadence
     * @type {number}
     * @memberof Cadence
     */
    id?: number;
    /**
     * Datetime of when the cadence was created
     * @type {string}
     * @memberof Cadence
     */
    createdAt?: string;
    /**
     * Datetime of when the cadence was last updated
     * @type {string}
     * @memberof Cadence
     */
    updatedAt?: string;
    /**
     * Datetime of when the cadence was archived, if archived
     * @type {string}
     * @memberof Cadence
     */
    archivedAt?: string;
    /**
     * Whether this cadence is a team cadence.  A team cadence is created by an admin and can be run by all users
     * @type {boolean}
     * @memberof Cadence
     */
    teamCadence?: boolean;
    /**
     * Whether this cadence is visible to team members (shared)
     * @type {boolean}
     * @memberof Cadence
     */
    shared?: boolean;
    /**
     * Whether this cadence is configured to automatically remove people who have bounced
     * @type {boolean}
     * @memberof Cadence
     */
    removeBouncesEnabled?: boolean;
    /**
     * Whether this cadence is configured to automatically remove people who have replied
     * @type {boolean}
     * @memberof Cadence
     */
    removeRepliesEnabled?: boolean;
    /**
     * Whether this cadence is configured to include an opt-out link by default
     * @type {boolean}
     * @memberof Cadence
     */
    optOutLinkIncluded?: boolean;
    /**
     * Cadence name
     * @type {string}
     * @memberof Cadence
     */
    name?: string;
    /**
     * All tags applied to this cadence
     * @type {Array<string>}
     * @memberof Cadence
     */
    tags?: Array<string>;
    /**
     * User that created this cadence
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    creator?: EmbeddedResource;
    /**
     * User that is marked as the owner of this cadence
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    owner?: EmbeddedResource;
    /**
     * Stage set when person on cadence bounces
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    bouncedStage?: EmbeddedResource;
    /**
     * Stage set when person on cadence replies
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    repliedStage?: EmbeddedResource;
    /**
     * Stage set when person is added to cadence
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    addedStage?: EmbeddedResource;
    /**
     * Stage set when person is finished with cadence
     * @type {EmbeddedResource}
     * @memberof Cadence
     */
    finishedStage?: EmbeddedResource;
    /**
     * Various counts for this cadence
     * @type {CadenceCounts}
     * @memberof Cadence
     */
    counts?: CadenceCounts;
}

/**
 * 
 * @export
 * @interface CadenceCounts
 */
export interface CadenceCounts {
    /**
     * The number of people that have ever been added to the cadence
     * @type {number}
     * @memberof CadenceCounts
     */
    cadencePeople?: number;
    /**
     * The user defined target for number of people to add to the cadence each day
     * @type {number}
     * @memberof CadenceCounts
     */
    targetDailyPeople?: number;
}

/**
 * 
 * @export
 * @interface CadenceMembership
 */
export interface CadenceMembership {
    /**
     * Cadence membership ID
     * @type {number}
     * @memberof CadenceMembership
     */
    id?: number;
    /**
     * Datetime of when the person was last added to this cadence
     * @type {string}
     * @memberof CadenceMembership
     */
    addedAt?: string;
    /**
     * Datetime of when the person was first added to this cadence
     * @type {string}
     * @memberof CadenceMembership
     */
    createdAt?: string;
    /**
     * Datetime of when the record was last updated
     * @type {string}
     * @memberof CadenceMembership
     */
    updatedAt?: string;
    /**
     * Whether the associated person has since been deleted
     * @type {boolean}
     * @memberof CadenceMembership
     */
    personDeleted?: boolean;
    /**
     * Whether the person is currently on the cadence
     * @type {boolean}
     * @memberof CadenceMembership
     */
    currentlyOnCadence?: boolean;
    /**
     * The current state of the person on the cadence. Possible values are:  processing: The person is being processed on a cadence. Cadence-related changes cannot be made at this time  staged: The person is waiting for the first step in the cadence to occur  active: The cadence has begun processing this person and is still in the process, but idle  scheduled: The cadence has begun processing this person and is still in the process, with an activity scheduled to occur  completed: The cadence has been completed for this person  removed: The person was manually or automatically removed from the cadence  removed_no_action: The person was removed from the cadence before any action occurred  reassigned: The person's cadence execution was transferred to a different user, ending this user's interaction 
     * @type {string}
     * @memberof CadenceMembership
     */
    currentState?: string;
    /**
     * The cadence that the person is on
     * @type {EmbeddedResource}
     * @memberof CadenceMembership
     */
    cadence?: EmbeddedResource;
    /**
     * The person that is on the cadence
     * @type {EmbeddedResource}
     * @memberof CadenceMembership
     */
    person?: EmbeddedResource;
    /**
     * The user that is acting on the person in the cadence
     * @type {EmbeddedResource}
     * @memberof CadenceMembership
     */
    user?: EmbeddedResource;
    /**
     * The most recent action associated with the record
     * @type {EmbeddedResource}
     * @memberof CadenceMembership
     */
    latestAction?: EmbeddedResource;
    /**
     * Various counts for the record
     * @type {CadenceMembershipCounts}
     * @memberof CadenceMembership
     */
    counts?: CadenceMembershipCounts;
}

/**
 * 
 * @export
 * @interface CadenceMembershipCounts
 */
export interface CadenceMembershipCounts {
    /**
     * The number of times emails sent from the cadence to the person were opened
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    views?: number;
    /**
     * The number of times emails sent from the cadence to the person were clicked
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    clicks?: number;
    /**
     * The number of times emails sent from the cadence to the person were replied to
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    replies?: number;
    /**
     * The number of times a call was logged from the cadence to the person
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    calls?: number;
    /**
     * The number of times emails were sent from the cadence to the person
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    sentEmails?: number;
    /**
     * The number of times emails sent from the cadence to the person bounced
     * @type {number}
     * @memberof CadenceMembershipCounts
     */
    bounces?: number;
}

/**
 * 
 * @export
 * @interface Call
 */
export interface Call {
    /**
     * ID of Call
     * @type {number}
     * @memberof Call
     */
    id?: number;
    /**
     * Phone number that received the call
     * @type {string}
     * @memberof Call
     */
    to?: string;
    /**
     * Length of the call in seconds
     * @type {number}
     * @memberof Call
     */
    duration?: number;
    /**
     * Outcome of the conversation
     * @type {string}
     * @memberof Call
     */
    sentiment?: string;
    /**
     * Result of the call
     * @type {string}
     * @memberof Call
     */
    disposition?: string;
    /**
     * Datetime of when the call was created
     * @type {string}
     * @memberof Call
     */
    createdAt?: string;
    /**
     * Datetime of when the call was last updated
     * @type {string}
     * @memberof Call
     */
    updatedAt?: string;
    /**
     * The recordings for this this call and their status
     * @type {Array<EmbeddedRecordingResource>}
     * @memberof Call
     */
    recordings?: Array<EmbeddedRecordingResource>;
    /**
     * User that made the call
     * @type {EmbeddedResource}
     * @memberof Call
     */
    user?: EmbeddedResource;
    /**
     * Action associated to the call
     * @type {EmbeddedResource}
     * @memberof Call
     */
    action?: EmbeddedResource;
    /**
     * The person called
     * @type {EmbeddedResource}
     * @memberof Call
     */
    calledPerson?: EmbeddedResource;
    /**
     * CRM Activity associated with the call
     * @type {EmbeddedResource}
     * @memberof Call
     */
    crmActivity?: EmbeddedResource;
    /**
     * Note for this call
     * @type {EmbeddedResource}
     * @memberof Call
     */
    note?: EmbeddedResource;
    /**
     * Cadence the call was made on
     * @type {EmbeddedResource}
     * @memberof Call
     */
    cadence?: EmbeddedResource;
    /**
     * Step the call was made on
     * @type {EmbeddedResource}
     * @memberof Call
     */
    step?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface CallDataRecord
 */
export interface CallDataRecord {
    /**
     * ID of CallDataRecord
     * @type {number}
     * @memberof CallDataRecord
     */
    id?: number;
    /**
     * Datetime of when the call was created
     * @type {string}
     * @memberof CallDataRecord
     */
    createdAt?: string;
    /**
     * Datetime of when the call was last updated
     * @type {string}
     * @memberof CallDataRecord
     */
    updatedAt?: string;
    /**
     * Phone number that received the call
     * @type {string}
     * @memberof CallDataRecord
     */
    to?: string;
    /**
     * Phone number that placed the call
     * @type {string}
     * @memberof CallDataRecord
     */
    from?: string;
    /**
     * Length of the call in seconds
     * @type {number}
     * @memberof CallDataRecord
     */
    duration?: number;
    /**
     * Direction of the call. Can be one of: inbound, outbound
     * @type {string}
     * @memberof CallDataRecord
     */
    direction?: string;
    /**
     * The outcome of the call. Can be one of: queued, initiated, ringing, in-progress, completed, busy, no-answer, canceled, failed
     * @type {string}
     * @memberof CallDataRecord
     */
    status?: string;
    /**
     * Type of the call. Can be one of: call, bridge, collaboration. Though exact values may change over time
     * @type {string}
     * @memberof CallDataRecord
     */
    callType?: string;
    /**
     * UUID of the call. Legs of the same call will have the same call_uuid.
     * @type {string}
     * @memberof CallDataRecord
     */
    callUuid?: string;
    /**
     * The recording for this this call data record, with a status
     * @type {EmbeddedRecordingResource}
     * @memberof CallDataRecord
     */
    recording?: EmbeddedRecordingResource;
    /**
     * Call that this record was logged to, if logged to a call
     * @type {EmbeddedResource}
     * @memberof CallDataRecord
     */
    call?: EmbeddedResource;
    /**
     * User that made or received the call, if the call was to a user
     * @type {EmbeddedResource}
     * @memberof CallDataRecord
     */
    user?: EmbeddedResource;
    /**
     * The person called
     * @type {EmbeddedResource}
     * @memberof CallDataRecord
     */
    calledPerson?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface CallDisposition
 */
export interface CallDisposition {
    /**
     * ID of CallDisposition
     * @type {number}
     * @memberof CallDisposition
     */
    id?: number;
    /**
     * Datetime of when the call disposition was created
     * @type {string}
     * @memberof CallDisposition
     */
    createdAt?: string;
    /**
     * Datetime of when the call disposition was last updated
     * @type {string}
     * @memberof CallDisposition
     */
    updatedAt?: string;
    /**
     * An available call disposition text
     * @type {string}
     * @memberof CallDisposition
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CallInstruction
 */
export interface CallInstruction {
    /**
     * ID of call instructions
     * @type {number}
     * @memberof CallInstruction
     */
    id?: number;
    /**
     * Datetime of when the call instructions were created
     * @type {string}
     * @memberof CallInstruction
     */
    createdAt?: string;
    /**
     * Datetime of when the call instructions were last updated
     * @type {string}
     * @memberof CallInstruction
     */
    updatedAt?: string;
    /**
     * The instructions
     * @type {string}
     * @memberof CallInstruction
     */
    instructions?: string;
}

/**
 * 
 * @export
 * @interface CallSentiment
 */
export interface CallSentiment {
    /**
     * ID of CallSentiment
     * @type {number}
     * @memberof CallSentiment
     */
    id?: number;
    /**
     * Datetime of when the call sentiment was created
     * @type {string}
     * @memberof CallSentiment
     */
    createdAt?: string;
    /**
     * Datetime of when the call sentiment was last updated
     * @type {string}
     * @memberof CallSentiment
     */
    updatedAt?: string;
    /**
     * An available call sentiment text
     * @type {string}
     * @memberof CallSentiment
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CallerId
 */
export interface CallerId {
    /**
     * The name of the person calling
     * @type {string}
     * @memberof CallerId
     */
    displayName?: string;
    /**
     * The title of the person calling
     * @type {string}
     * @memberof CallerId
     */
    title?: string;
    /**
     * The account of the person calling
     * @type {string}
     * @memberof CallerId
     */
    accountName?: string;
    /**
     * The person calling
     * @type {EmbeddedResource}
     * @memberof CallerId
     */
    person?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface CrmActivity
 */
export interface CrmActivity {
    /**
     * CrmActivity ID
     * @type {number}
     * @memberof CrmActivity
     */
    id?: number;
    /**
     * Datetime of when the crm activity was created
     * @type {string}
     * @memberof CrmActivity
     */
    createdAt?: string;
    /**
     * Datetime of when the crm activity was last updated
     * @type {string}
     * @memberof CrmActivity
     */
    updatedAt?: string;
    /**
     * The subject field of the activity in Salesforce
     * @type {string}
     * @memberof CrmActivity
     */
    subject?: string;
    /**
     * The description field of the activity in Salesforce
     * @type {string}
     * @memberof CrmActivity
     */
    description?: string;
    /**
     * The ID of the activity in Salesforce, if written to Salesforce
     * @type {string}
     * @memberof CrmActivity
     */
    crmId?: string;
    /**
     * The type of activity that is being recorded, if available. The values can change over time, but could be one of: email, phone, email reminder, inmail
     * @type {string}
     * @memberof CrmActivity
     */
    activityType?: string;
    /**
     * Information about why this crm activity failed to sync, if it did fail to sync. Failed activities will be automatically retried and may become successful in the future
     * @type {string}
     * @memberof CrmActivity
     */
    error?: string;
    /**
     * Additional fields that are logged to Salesforce, if mapped by the team at the time of writing to Salesforce
     * @type {any}
     * @memberof CrmActivity
     */
    customCrmFields?: any;
    /**
     * Person that this crm activity is for
     * @type {EmbeddedResource}
     * @memberof CrmActivity
     */
    person?: EmbeddedResource;
    /**
     * User that triggered this crm activity
     * @type {EmbeddedResource}
     * @memberof CrmActivity
     */
    user?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface CrmActivityField
 */
export interface CrmActivityField {
    /**
     * ID of CrmActivityField
     * @type {number}
     * @memberof CrmActivityField
     */
    id?: number;
    /**
     * Datetime of when the CrmActivityField was created
     * @type {string}
     * @memberof CrmActivityField
     */
    createdAt?: string;
    /**
     * Datetime of when the CrmActivityField was last updated
     * @type {string}
     * @memberof CrmActivityField
     */
    updatedAt?: string;
    /**
     * A human friendly title for this field
     * @type {string}
     * @memberof CrmActivityField
     */
    title?: string;
    /**
     * The Salesforce object type that this field maps to. Valid object types are: Task. More object types may be added in the future. 
     * @type {string}
     * @memberof CrmActivityField
     */
    salesforceObjectType?: string;
    /**
     * SalesLoft object that this field is mapped for. Valid sources are: email, phone
     * @type {string}
     * @memberof CrmActivityField
     */
    source?: string;
    /**
     * The Salesforce field name
     * @type {string}
     * @memberof CrmActivityField
     */
    field?: string;
    /**
     * The type of this field in Salesforce. Certain field types can only accept structured input.
     * @type {string}
     * @memberof CrmActivityField
     */
    fieldType?: string;
    /**
     * A value to always be written. This value does not need to be sent to other endpoints' crm params, but must be the exact value if sent. Email source fields will always have a value present. 
     * @type {string}
     * @memberof CrmActivityField
     */
    value?: string;
    /**
     * Valid picklist values, if present for this field. The format is {label => value}. If present, only values in the picklist structure can be used as a crm param. 
     * @type {any}
     * @memberof CrmActivityField
     */
    picklistValues?: any;
}

/**
 * 
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * ID of Custom Field
     * @type {number}
     * @memberof CustomField
     */
    id?: number;
    /**
     * Name of the Custom Field
     * @type {string}
     * @memberof CustomField
     */
    name?: string;
    /**
     * Type of the Custom Field. Value must be one of: person, company, opportunity.
     * @type {string}
     * @memberof CustomField
     */
    fieldType?: string;
    /**
     * Value Type of the Custom Field. Value must be one of: text, date.
     * @type {string}
     * @memberof CustomField
     */
    valueType?: string;
    /**
     * Datetime of when the Custom Field was created
     * @type {string}
     * @memberof CustomField
     */
    createdAt?: string;
    /**
     * Datetime of when the Custom Field was last updated
     * @type {string}
     * @memberof CustomField
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * ID of Email
     * @type {number}
     * @memberof Email
     */
    id?: number;
    /**
     * Datetime of when the email was created
     * @type {string}
     * @memberof Email
     */
    createdAt?: string;
    /**
     * Datetime of when the email was last updated
     * @type {string}
     * @memberof Email
     */
    updatedAt?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof Email
     */
    recipientEmailAddress?: string;
    /**
     * Status of this email through the sending process. Possible values are: sent, sent_from_gmail, sent_from_external, pending, pending_reply_check, scheduled, sending, delivering, failed, cancelled, pending_through_gmail, pending_through_external
     * @type {string}
     * @memberof Email
     */
    status?: string;
    /**
     * Whether this email bounced
     * @type {boolean}
     * @memberof Email
     */
    bounced?: boolean;
    /**
     * When this email will be sent, or null if already sent
     * @type {string}
     * @memberof Email
     */
    sendAfter?: string;
    /**
     * When this email was sent, or null if it was not sent
     * @type {string}
     * @memberof Email
     */
    sentAt?: string;
    /**
     * Whether this email had view tracking enabled
     * @type {boolean}
     * @memberof Email
     */
    viewTracking?: boolean;
    /**
     * Whether this email had click tracking enabled
     * @type {boolean}
     * @memberof Email
     */
    clickTracking?: boolean;
    /**
     * Selected headers that are included if this email used them. Available keys are: cc, bcc
     * @type {any}
     * @memberof Email
     */
    headers?: any;
    /**
     * Various counts for this email
     * @type {EmailCounts}
     * @memberof Email
     */
    counts?: EmailCounts;
    /**
     * User that sent this email
     * @type {EmbeddedResource}
     * @memberof Email
     */
    user?: EmbeddedResource;
    /**
     * The person whom received this email
     * @type {EmbeddedResource}
     * @memberof Email
     */
    recipient?: EmbeddedResource;
    /**
     * The mailing that this email was a part of
     * @type {EmbeddedResource}
     * @memberof Email
     */
    mailing?: EmbeddedResource;
    /**
     * Action that this email was sent from, or null if not sent through a cadence
     * @type {EmbeddedResource}
     * @memberof Email
     */
    action?: EmbeddedResource;
    /**
     * CRM Activity associated with this email
     * @type {EmbeddedResource}
     * @memberof Email
     */
    crmActivity?: EmbeddedResource;
    /**
     * Cadence the email was sent on
     * @type {EmbeddedResource}
     * @memberof Email
     */
    cadence?: EmbeddedResource;
    /**
     * Step the email was sent on
     * @type {EmbeddedResource}
     * @memberof Email
     */
    step?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface EmailCounts
 */
export interface EmailCounts {
    /**
     * The number of times links in the email were clicked
     * @type {number}
     * @memberof EmailCounts
     */
    clicks?: number;
    /**
     * The number of times the email was opened
     * @type {number}
     * @memberof EmailCounts
     */
    views?: number;
    /**
     * The number of replies the email received
     * @type {number}
     * @memberof EmailCounts
     */
    replies?: number;
    /**
     * The number of unique devices that opened the email
     * @type {number}
     * @memberof EmailCounts
     */
    uniqueDevices?: number;
    /**
     * The number of unique locations that opened the email
     * @type {number}
     * @memberof EmailCounts
     */
    uniqueLocations?: number;
    /**
     * The number of attachments on the email
     * @type {number}
     * @memberof EmailCounts
     */
    attachments?: number;
}

/**
 * 
 * @export
 * @interface EmailTemplate
 */
export interface EmailTemplate {
    /**
     * ID of email template
     * @type {number}
     * @memberof EmailTemplate
     */
    id?: number;
    /**
     * Title of the email template
     * @type {string}
     * @memberof EmailTemplate
     */
    title?: string;
    /**
     * Subject of the email template
     * @type {string}
     * @memberof EmailTemplate
     */
    subject?: string;
    /**
     * Sanitized body of the email template without email signature
     * @type {string}
     * @memberof EmailTemplate
     */
    body?: string;
    /**
     * A plain text version of the first 100 characters of the body of the email template
     * @type {string}
     * @memberof EmailTemplate
     */
    bodyPreview?: string;
    /**
     * Datetime of when the email template was created
     * @type {string}
     * @memberof EmailTemplate
     */
    createdAt?: string;
    /**
     * Datetime of when the email template was last updated
     * @type {string}
     * @memberof EmailTemplate
     */
    updatedAt?: string;
    /**
     * Datetime of when the email template was last used
     * @type {string}
     * @memberof EmailTemplate
     */
    lastUsedAt?: string;
    /**
     * Datetime of when the email template was archived, if archived
     * @type {string}
     * @memberof EmailTemplate
     */
    archivedAt?: string;
    /**
     * Whether this email template is visible to team members (shared)
     * @type {boolean}
     * @memberof EmailTemplate
     */
    shared?: boolean;
    /**
     * Whether open tracking is enabled for this email template
     * @type {boolean}
     * @memberof EmailTemplate
     */
    openTrackingEnabled?: boolean;
    /**
     * Whether click tracking is enabled for this email template
     * @type {boolean}
     * @memberof EmailTemplate
     */
    clickTrackingEnabled?: boolean;
    /**
     * Whether this email template is only used on a cadence step. These templates are not visible in the SalesLoft application template list. If false, this email template is visible in the SalesLoft application, and may be used when composing an email or creating a cadence step.
     * @type {boolean}
     * @memberof EmailTemplate
     */
    cadenceTemplate?: boolean;
    /**
     * Various counts for this team template
     * @type {EmailTemplateCounts}
     * @memberof EmailTemplate
     */
    counts?: EmailTemplateCounts;
    /**
     * User that owns this email template
     * @type {EmbeddedResource}
     * @memberof EmailTemplate
     */
    templateOwner?: EmbeddedResource;
    /**
     * Associated team template, if any
     * @type {EmbeddedResource}
     * @memberof EmailTemplate
     */
    teamTemplate?: EmbeddedResource;
    /**
     * Links to attachments and tags resources for this email template.
     * @type {any}
     * @memberof EmailTemplate
     */
    links?: any;
    /**
     * All tags applied to this email template
     * @type {Array<string>}
     * @memberof EmailTemplate
     */
    tags?: Array<string>;
    /**
     * Groups to which this template is assigned, if any
     * @type {Array<EmbeddedResource>}
     * @memberof EmailTemplate
     */
    groups?: Array<EmbeddedResource>;
}

/**
 * 
 * @export
 * @interface EmailTemplateAttachment
 */
export interface EmailTemplateAttachment {
    /**
     * ID of email template attachment association
     * @type {number}
     * @memberof EmailTemplateAttachment
     */
    id?: number;
    /**
     * ID of the email template attachment
     * @type {number}
     * @memberof EmailTemplateAttachment
     */
    attachmentId?: number;
    /**
     * Link and id of specific email template
     * @type {EmbeddedResource}
     * @memberof EmailTemplateAttachment
     */
    emailTemplate?: EmbeddedResource;
    /**
     * Name of the attachment
     * @type {string}
     * @memberof EmailTemplateAttachment
     */
    name?: string;
    /**
     * Download url of the attachment
     * @type {string}
     * @memberof EmailTemplateAttachment
     */
    downloadUrl?: string;
    /**
     * The size of the attachment
     * @type {number}
     * @memberof EmailTemplateAttachment
     */
    attachmentFileSize?: number;
}

/**
 * 
 * @export
 * @interface EmailTemplateCounts
 */
export interface EmailTemplateCounts {
    /**
     * The number of times the email template was sent out
     * @type {number}
     * @memberof EmailTemplateCounts
     */
    sentEmails?: number;
    /**
     * The number of times the email template was opened
     * @type {number}
     * @memberof EmailTemplateCounts
     */
    views?: number;
    /**
     * The number of times links in the email template were clicked
     * @type {number}
     * @memberof EmailTemplateCounts
     */
    clicks?: number;
    /**
     * The number of replies the email template received
     * @type {number}
     * @memberof EmailTemplateCounts
     */
    replies?: number;
    /**
     * The number of bounces the email template received
     * @type {number}
     * @memberof EmailTemplateCounts
     */
    bounces?: number;
}

/**
 * 
 * @export
 * @interface EmbeddedAccountCounts
 */
export interface EmbeddedAccountCounts {
    /**
     * Number of people in SalesLoft associated with this Account
     * @type {number}
     * @memberof EmbeddedAccountCounts
     */
    people?: number;
}

/**
 * 
 * @export
 * @interface EmbeddedRecordingResource
 */
export interface EmbeddedRecordingResource {
    /**
     * The url of the recording
     * @type {string}
     * @memberof EmbeddedRecordingResource
     */
    url?: string;
    /**
     * The status of the call that produced this recording. Possible values are (but not limited to):  no-answer: The call was not answered  failed: The call was not able to be placed  busy: The call was busy  ringing: The call is ringing  in-progress: The call is ongoing  completed: The call is finished 
     * @type {string}
     * @memberof EmbeddedRecordingResource
     */
    status?: string;
    /**
     * The processing status of the recording. Possible values are (but not limited to):  not_recorded: there is no recording available, and there will not be one becoming available  pending: the recording is currently being processed by the system  processing: the recording is currently being processed by the system  completed: the recording processing has been completed 
     * @type {string}
     * @memberof EmbeddedRecordingResource
     */
    recordingStatus?: string;
}

/**
 * 
 * @export
 * @interface EmbeddedResource
 */
export interface EmbeddedResource {
    /**
     * Resource URL, pointed at your API version, present if this resource is available in the API
     * @type {string}
     * @memberof EmbeddedResource
     */
    href?: string;
    /**
     * ID of the resource
     * @type {number}
     * @memberof EmbeddedResource
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface LiveWebsiteTrackingParameter
 */
export interface LiveWebsiteTrackingParameter {
    /**
     * A SalesLoft identifier
     * @type {Array<any>}
     * @memberof LiveWebsiteTrackingParameter
     */
    parameters?: Array<any>;
}

/**
 * 
 * @export
 * @interface ModelImport
 */
export interface ModelImport {
    /**
     * Import ID
     * @type {number}
     * @memberof ModelImport
     */
    id?: number;
    /**
     * Datetime of when the import was created
     * @type {string}
     * @memberof ModelImport
     */
    createdAt?: string;
    /**
     * Datetime of when the import was last updated, ignoring relationship changes
     * @type {string}
     * @memberof ModelImport
     */
    updatedAt?: string;
    /**
     * Name of Import
     * @type {string}
     * @memberof ModelImport
     */
    name?: string;
    /**
     * Count of People that have not been deleted
     * @type {number}
     * @memberof ModelImport
     */
    currentPeopleCount?: number;
    /**
     * Count of People that have ever been on this Import
     * @type {number}
     * @memberof ModelImport
     */
    importedPeopleCount?: number;
}

/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * Note ID
     * @type {number}
     * @memberof Note
     */
    id?: number;
    /**
     * The content of the note
     * @type {string}
     * @memberof Note
     */
    content?: string;
    /**
     * Datetime of when the note was created
     * @type {string}
     * @memberof Note
     */
    createdAt?: string;
    /**
     * Datetime of when the note was last updated
     * @type {string}
     * @memberof Note
     */
    updatedAt?: string;
    /**
     * User that wrote this note
     * @type {EmbeddedResource}
     * @memberof Note
     */
    user?: EmbeddedResource;
    /**
     * Item on which the note was made
     * @type {EmbeddedResource}
     * @memberof Note
     */
    associatedWith?: EmbeddedResource;
    /**
     * Call linked to the note
     * @type {EmbeddedResource}
     * @memberof Note
     */
    call?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * Person ID
     * @type {number}
     * @memberof Person
     */
    id?: number;
    /**
     * Datetime of when the person was created
     * @type {string}
     * @memberof Person
     */
    createdAt?: string;
    /**
     * Datetime of when the person was last updated
     * @type {string}
     * @memberof Person
     */
    updatedAt?: string;
    /**
     * Last datetime this person was contacted
     * @type {string}
     * @memberof Person
     */
    lastContactedAt?: string;
    /**
     * Last datetime this person replied to an email
     * @type {string}
     * @memberof Person
     */
    lastRepliedAt?: string;
    /**
     * First name
     * @type {string}
     * @memberof Person
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof Person
     */
    lastName?: string;
    /**
     * Either the full name or the email address. Use this when showing a person's name
     * @type {string}
     * @memberof Person
     */
    displayName?: string;
    /**
     * Email address
     * @type {string}
     * @memberof Person
     */
    emailAddress?: string;
    /**
     * Alternate email address
     * @type {string}
     * @memberof Person
     */
    secondaryEmailAddress?: string;
    /**
     * Personal email address
     * @type {string}
     * @memberof Person
     */
    personalEmailAddress?: string;
    /**
     * Phone without formatting
     * @type {string}
     * @memberof Person
     */
    phone?: string;
    /**
     * Phone extension without formatting
     * @type {string}
     * @memberof Person
     */
    phoneExtension?: string;
    /**
     * Home phone without formatting
     * @type {string}
     * @memberof Person
     */
    homePhone?: string;
    /**
     * Mobile phone without formatting
     * @type {string}
     * @memberof Person
     */
    mobilePhone?: string;
    /**
     * Linkedin URL
     * @type {string}
     * @memberof Person
     */
    linkedinUrl?: string;
    /**
     * Job title
     * @type {string}
     * @memberof Person
     */
    title?: string;
    /**
     * City
     * @type {string}
     * @memberof Person
     */
    city?: string;
    /**
     * State
     * @type {string}
     * @memberof Person
     */
    state?: string;
    /**
     * Country
     * @type {string}
     * @memberof Person
     */
    country?: string;
    /**
     * Work location - city
     * @type {string}
     * @memberof Person
     */
    workCity?: string;
    /**
     * Work location - state
     * @type {string}
     * @memberof Person
     */
    workState?: string;
    /**
     * Work location - country
     * @type {string}
     * @memberof Person
     */
    workCountry?: string;
    /**
     * CRM url, currently Salesforce.com only
     * @type {string}
     * @memberof Person
     */
    crmUrl?: string;
    /**
     * CRM ID, currently Salesforce.com only
     * @type {string}
     * @memberof Person
     */
    crmId?: string;
    /**
     * CRM object type, currently Salesforce.com only
     * @type {string}
     * @memberof Person
     */
    crmObjectType?: string;
    /**
     * Mapped owner field from the CRM, currently Salesforce.com only
     * @type {string}
     * @memberof Person
     */
    ownerCrmId?: string;
    /**
     * Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @type {string}
     * @memberof Person
     */
    personCompanyName?: string;
    /**
     * Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @type {string}
     * @memberof Person
     */
    personCompanyWebsite?: string;
    /**
     * Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @type {string}
     * @memberof Person
     */
    personCompanyIndustry?: string;
    /**
     * Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
     * @type {boolean}
     * @memberof Person
     */
    doNotContact?: boolean;
    /**
     * Whether this person's current email address has bounced
     * @type {boolean}
     * @memberof Person
     */
    bouncing?: boolean;
    /**
     * Time locale of the person
     * @type {string}
     * @memberof Person
     */
    locale?: string;
    /**
     * The website of this person
     * @type {string}
     * @memberof Person
     */
    personalWebsite?: string;
    /**
     * The twitter handle of this person
     * @type {string}
     * @memberof Person
     */
    twitterHandle?: string;
    /**
     * The type of the last touch to this person. Can be call, email, other
     * @type {string}
     * @memberof Person
     */
    lastContactedType?: string;
    /**
     * The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
     * @type {string}
     * @memberof Person
     */
    jobSeniority?: string;
    /**
     * Custom fields are defined by the user's team. Only fields with values are presented in the API.
     * @type {any}
     * @memberof Person
     */
    customFields?: any;
    /**
     * All tags applied to this person
     * @type {Array<string>}
     * @memberof Person
     */
    tags?: Array<string>;
    /**
     * Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
     * @type {Array<string>}
     * @memberof Person
     */
    contactRestrictions?: Array<string>;
    /**
     * Various counts for this person
     * @type {PersonCounts}
     * @memberof Person
     */
    counts?: PersonCounts;
    /**
     * Account that this person is associated to
     * @type {EmbeddedResource}
     * @memberof Person
     */
    account?: EmbeddedResource;
    /**
     * User that is marked as the owner of this person
     * @type {EmbeddedResource}
     * @memberof Person
     */
    owner?: EmbeddedResource;
    /**
     * User that last contacted this person
     * @type {EmbeddedResource}
     * @memberof Person
     */
    lastContactedBy?: EmbeddedResource;
    /**
     * Import that this person was a part of
     * @type {EmbeddedResource}
     * @memberof Person
     */
    _import?: EmbeddedResource;
    /**
     * Person stage that this person has set
     * @type {EmbeddedResource}
     * @memberof Person
     */
    personStage?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface PersonCounts
 */
export interface PersonCounts {
    /**
     * The number of emails sent to this person
     * @type {number}
     * @memberof PersonCounts
     */
    emailsSent?: number;
    /**
     * The number of unique emails viewed by this person
     * @type {number}
     * @memberof PersonCounts
     */
    emailsViewed?: number;
    /**
     * The number of unique emails clicked by this person
     * @type {number}
     * @memberof PersonCounts
     */
    emailsClicked?: number;
    /**
     * The number of unique emails replied to by this person
     * @type {number}
     * @memberof PersonCounts
     */
    emailsRepliedTo?: number;
    /**
     * The number of unique emails sent to this person that bounced
     * @type {number}
     * @memberof PersonCounts
     */
    emailsBounced?: number;
    /**
     * The number of calls logged to this person
     * @type {number}
     * @memberof PersonCounts
     */
    calls?: number;
}

/**
 * 
 * @export
 * @interface PersonStage
 */
export interface PersonStage {
    /**
     * ID of Person Stage
     * @type {number}
     * @memberof PersonStage
     */
    id?: number;
    /**
     * Name of Person Stage
     * @type {string}
     * @memberof PersonStage
     */
    name?: string;
    /**
     * Datetime of when the Person Stage was created
     * @type {string}
     * @memberof PersonStage
     */
    createdAt?: string;
    /**
     * Datetime of when the Person Stage was last updated
     * @type {string}
     * @memberof PersonStage
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface PhoneNumberAssignment
 */
export interface PhoneNumberAssignment {
    /**
     * PhoneNumberAssignment ID
     * @type {number}
     * @memberof PhoneNumberAssignment
     */
    id?: number;
    /**
     * The phone number associated with this assignment
     * @type {string}
     * @memberof PhoneNumberAssignment
     */
    number?: string;
    /**
     * User associated with this phone number assignment
     * @type {EmbeddedResource}
     * @memberof PhoneNumberAssignment
     */
    user?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface RecordingSetting
 */
export interface RecordingSetting {
    /**
     * Whether this phone number should record by default
     * @type {boolean}
     * @memberof RecordingSetting
     */
    recordingDefault?: boolean;
}

/**
 * 
 * @export
 * @interface SavedListView
 */
export interface SavedListView {
    /**
     * ID of Ssaved list view
     * @type {number}
     * @memberof SavedListView
     */
    id?: number;
    /**
     * Type of saved list view
     * @type {string}
     * @memberof SavedListView
     */
    view?: string;
    /**
     * Name of saved list view
     * @type {string}
     * @memberof SavedListView
     */
    name?: string;
    /**
     * List of set filters in saved list view
     * @type {any}
     * @memberof SavedListView
     */
    viewParams?: any;
    /**
     * Whether the saved list view is the default view
     * @type {boolean}
     * @memberof SavedListView
     */
    isDefault?: boolean;
}

/**
 * 
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * ID of Step
     * @type {number}
     * @memberof Step
     */
    id?: number;
    /**
     * Datetime of when the Step was created
     * @type {string}
     * @memberof Step
     */
    createdAt?: string;
    /**
     * Datetime of when the Step was last updated
     * @type {string}
     * @memberof Step
     */
    updatedAt?: string;
    /**
     * Whether this step is currently active
     * @type {boolean}
     * @memberof Step
     */
    disabled?: boolean;
    /**
     * The type of the action scheduled by this step. Valid types are: email, phone, integration, other. New types may be added in the future. 
     * @type {string}
     * @memberof Step
     */
    type?: string;
    /**
     * Display name of the step
     * @type {string}
     * @memberof Step
     */
    displayName?: string;
    /**
     * Day this step is associated with up
     * @type {number}
     * @memberof Step
     */
    day?: number;
    /**
     * The number of the step for this day
     * @type {number}
     * @memberof Step
     */
    stepNumber?: number;
    /**
     * Details pertaining to the specific step type
     * @type {EmbeddedResource}
     * @memberof Step
     */
    details?: EmbeddedResource;
    /**
     * The cadence of the step
     * @type {EmbeddedResource}
     * @memberof Step
     */
    cadence?: EmbeddedResource;
}

/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * ID of success
     * @type {number}
     * @memberof Success
     */
    id?: number;
    /**
     * Datetime of when the success was created
     * @type {string}
     * @memberof Success
     */
    createdAt?: string;
    /**
     * Datetime of when the success was last updated
     * @type {string}
     * @memberof Success
     */
    updatedAt?: string;
    /**
     * Datetime of when the success was recorded
     * @type {string}
     * @memberof Success
     */
    succeededAt?: string;
    /**
     * Datetime of when this person was first worked, leading up to the success
     * @type {string}
     * @memberof Success
     */
    successWindowStartedAt?: string;
    /**
     * User that created this success
     * @type {EmbeddedResource}
     * @memberof Success
     */
    user?: EmbeddedResource;
    /**
     * The person who a success occurred on
     * @type {EmbeddedResource}
     * @memberof Success
     */
    person?: EmbeddedResource;
    /**
     * The email that was most recently sent to this person before the success
     * @type {EmbeddedResource}
     * @memberof Success
     */
    latestEmail?: EmbeddedResource;
    /**
     * The call that was most recently made to this person before the success
     * @type {EmbeddedResource}
     * @memberof Success
     */
    latestCall?: EmbeddedResource;
    /**
     * The action that was most recently completed on this person before the success
     * @type {EmbeddedResource}
     * @memberof Success
     */
    latestAction?: EmbeddedResource;
    /**
     * The cadence with the action that was most recently completed on this person before the success
     * @type {EmbeddedResource}
     * @memberof Success
     */
    latestCadence?: EmbeddedResource;
    /**
     * Various counts for this success
     * @type {SuccessCounts}
     * @memberof Success
     */
    counts?: SuccessCounts;
}

/**
 * 
 * @export
 * @interface SuccessCounts
 */
export interface SuccessCounts {
    /**
     * The total number of emails made in this success window
     * @type {number}
     * @memberof SuccessCounts
     */
    totalEmails?: number;
    /**
     * The total number of calls made in this success window
     * @type {number}
     * @memberof SuccessCounts
     */
    totalCalls?: number;
    /**
     * The total number of other touches made in this success window
     * @type {number}
     * @memberof SuccessCounts
     */
    totalOtherTouches?: number;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * ID of Tag
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * Name of the tag
     * @type {string}
     * @memberof Tag
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * Team ID
     * @type {number}
     * @memberof Team
     */
    id?: number;
    /**
     * Team name
     * @type {string}
     * @memberof Team
     */
    name?: string;
    /**
     * Datetime of when the team was created
     * @type {string}
     * @memberof Team
     */
    createdAt?: string;
    /**
     * Datetime of when the team was last updated
     * @type {string}
     * @memberof Team
     */
    updatedAt?: string;
    /**
     * Visibility setting for resources across the team. Possible values are: group_public, all_public. When the value is group_public, certain resources will only be visible to members of the same group. When the value is all_public, all resources are visible to all users on this team. 
     * @type {string}
     * @memberof Team
     */
    groupPrivacySetting?: string;
    /**
     * The default visibility of resources on the team, in the UI only. The API does not utilize this default. Possible values are: public, private. 
     * @type {string}
     * @memberof Team
     */
    teamVisibilityDefault?: string;
    /**
     * Plan type of the team, Possible values are: group, professional, enterprise
     * @type {string}
     * @memberof Team
     */
    plan?: string;
    /**
     * Count of seats that this team has licensed
     * @type {number}
     * @memberof Team
     */
    licenseLimit?: number;
    /**
     * Whether this team has local dial enabled
     * @type {boolean}
     * @memberof Team
     */
    localDialEnabled?: boolean;
    /**
     * Whether calls will record by default
     * @type {boolean}
     * @memberof Team
     */
    recordByDefault?: boolean;
    /**
     * Whether all call recording is disabled
     * @type {boolean}
     * @memberof Team
     */
    callRecordingDisabled?: boolean;
    /**
     * Daily email limit for each member on the team
     * @type {number}
     * @memberof Team
     */
    emailDailyLimit?: number;
    /**
     * The team default for click tracking when composing emails
     * @type {boolean}
     * @memberof Team
     */
    clickTrackingDefault?: boolean;
    /**
     * Whether team members are allowed to have automated email steps
     * @type {boolean}
     * @memberof Team
     */
    allowAutomatedEmailSteps?: boolean;
    /**
     * The domain click and open tracking will be proxied through
     * @type {string}
     * @memberof Team
     */
    customTrackingDomain?: string;
    /**
     * Whether team members are required to mark disposition at the end of calls
     * @type {boolean}
     * @memberof Team
     */
    dispositionsRequired?: boolean;
    /**
     * Whether team members are required to log sentiments
     * @type {boolean}
     * @memberof Team
     */
    sentimentsRequired?: boolean;
}

/**
 * 
 * @export
 * @interface TeamTemplate
 */
export interface TeamTemplate {
    /**
     * ID of team template
     * @type {string}
     * @memberof TeamTemplate
     */
    id?: string;
    /**
     * Title of the team template
     * @type {string}
     * @memberof TeamTemplate
     */
    title?: string;
    /**
     * Subject of the team template
     * @type {string}
     * @memberof TeamTemplate
     */
    subject?: string;
    /**
     * Body of the team template
     * @type {string}
     * @memberof TeamTemplate
     */
    body?: string;
    /**
     * A plain text version of the first 100 characters of the body of the team template
     * @type {string}
     * @memberof TeamTemplate
     */
    bodyPreview?: string;
    /**
     * Datetime of when the team template was created
     * @type {string}
     * @memberof TeamTemplate
     */
    createdAt?: string;
    /**
     * Datetime of when the team template was last updated
     * @type {string}
     * @memberof TeamTemplate
     */
    updatedAt?: string;
    /**
     * Datetime of when the team template was last used
     * @type {string}
     * @memberof TeamTemplate
     */
    lastUsedAt?: string;
    /**
     * Datetime of when the team template was archived, if archived
     * @type {string}
     * @memberof TeamTemplate
     */
    archivedAt?: string;
    /**
     * Datetime of when the team template was last modified
     * @type {string}
     * @memberof TeamTemplate
     */
    lastModifiedAt?: string;
    /**
     * Whether open tracking is enabled for this team template
     * @type {boolean}
     * @memberof TeamTemplate
     */
    openTrackingEnabled?: boolean;
    /**
     * Whether click tracking is enabled for this team template
     * @type {boolean}
     * @memberof TeamTemplate
     */
    clickTrackingEnabled?: boolean;
    /**
     * Various counts for this team template. Counts will update over time but will not affect the 'updated at' field for the team template.
     * @type {TeamTemplateCounts}
     * @memberof TeamTemplate
     */
    counts?: TeamTemplateCounts;
    /**
     * User that last modified this team template
     * @type {EmbeddedResource}
     * @memberof TeamTemplate
     */
    lastModifiedUser?: EmbeddedResource;
    /**
     * Links to attachments resource for this template 
     * @type {any}
     * @memberof TeamTemplate
     */
    links?: any;
    /**
     * All tags applied to this team template
     * @type {Array<string>}
     * @memberof TeamTemplate
     */
    tags?: Array<string>;
}

/**
 * 
 * @export
 * @interface TeamTemplateAttachment
 */
export interface TeamTemplateAttachment {
    /**
     * ID of team template attachment association
     * @type {number}
     * @memberof TeamTemplateAttachment
     */
    id?: number;
    /**
     * ID of the team template attachment
     * @type {number}
     * @memberof TeamTemplateAttachment
     */
    attachmentId?: number;
    /**
     * Details pertaining to the specific team template
     * @type {EmbeddedResource}
     * @memberof TeamTemplateAttachment
     */
    teamTemplate?: EmbeddedResource;
    /**
     * Name of the attachment
     * @type {string}
     * @memberof TeamTemplateAttachment
     */
    name?: string;
    /**
     * Download url of the attachment
     * @type {string}
     * @memberof TeamTemplateAttachment
     */
    downloadUrl?: string;
    /**
     * The size of the attachment
     * @type {number}
     * @memberof TeamTemplateAttachment
     */
    attachmentFileSize?: number;
}

/**
 * 
 * @export
 * @interface TeamTemplateCounts
 */
export interface TeamTemplateCounts {
    /**
     * The number of times the team template was sent out
     * @type {number}
     * @memberof TeamTemplateCounts
     */
    sentEmails?: number;
    /**
     * The number of times the team template was opened
     * @type {number}
     * @memberof TeamTemplateCounts
     */
    views?: number;
    /**
     * The number of times links in the team template were clicked
     * @type {number}
     * @memberof TeamTemplateCounts
     */
    clicks?: number;
    /**
     * The number of replies the team template received
     * @type {number}
     * @memberof TeamTemplateCounts
     */
    replies?: number;
    /**
     * The number of bounces the team template received
     * @type {number}
     * @memberof TeamTemplateCounts
     */
    bounces?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Globally unique user ID. New endpoints will explicitly accept this over id
     * @type {string}
     * @memberof User
     */
    guid?: string;
    /**
     * Datetime of when the user was created
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * Datetime of when the user was last updated
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
    /**
     * Display name of user
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * First name of user
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * Last name of user
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * Whether an user is currently active in SalesLoft
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
    /**
     * User Time Zone
     * @type {string}
     * @memberof User
     */
    timeZone?: string;
    /**
     * Slack username
     * @type {string}
     * @memberof User
     */
    slackUsername?: string;
    /**
     * Twitter handle
     * @type {string}
     * @memberof User
     */
    twitterHandle?: string;
    /**
     * Email address provided to accounts.salesloft.com
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Email address associated with the email client of the user
     * @type {string}
     * @memberof User
     */
    emailClientEmailAddress?: string;
    /**
     * The email address that email of the user will be sent from, resolved in the following resolution order: from_user, email_client_email_address, email
     * @type {string}
     * @memberof User
     */
    sendingEmailAddress?: string;
    /**
     * The from address of this user
     * @type {string}
     * @memberof User
     */
    fromAddress?: string;
    /**
     * RFC 5322 compliant email address
     * @type {string}
     * @memberof User
     */
    fullEmailAddress?: string;
    /**
     * Address that will be BBC'd on all emails from this user
     * @type {string}
     * @memberof User
     */
    bccEmailAddress?: string;
    /**
     * Email signature
     * @type {string}
     * @memberof User
     */
    emailSignature?: string;
    /**
     * Email signature type
     * @type {string}
     * @memberof User
     */
    emailSignatureType?: string;
    /**
     * Whether this user has click tracking disabled in email signature
     * @type {boolean}
     * @memberof User
     */
    emailSignatureClickTrackingDisabled?: boolean;
    /**
     * Team Admin
     * @type {boolean}
     * @memberof User
     */
    teamAdmin?: boolean;
    /**
     * Whether this user has Local Dial enabled
     * @type {boolean}
     * @memberof User
     */
    localDialEnabled?: boolean;
    /**
     * Whether this user has click to call enabled
     * @type {boolean}
     * @memberof User
     */
    clickToCallEnabled?: boolean;
    /**
     * Whether this user has a email client configured
     * @type {boolean}
     * @memberof User
     */
    emailClientConfigured?: boolean;
    /**
     * Whether the user has a crm connected
     * @type {boolean}
     * @memberof User
     */
    crmConnected?: boolean;
    /**
     * Feature flags that are for this user. New flags may appear or disappear at any time
     * @type {any}
     * @memberof User
     */
    externalFeatureFlags?: any;
    /**
     * Phone Client of user
     * @type {EmbeddedResource}
     * @memberof User
     */
    phoneClient?: EmbeddedResource;
    /**
     * Phone number assignment of user
     * @type {EmbeddedResource}
     * @memberof User
     */
    phoneNumberAssignment?: EmbeddedResource;
    /**
     * Group of user
     * @type {EmbeddedResource}
     * @memberof User
     */
    group?: EmbeddedResource;
    /**
     * Team of user
     * @type {EmbeddedResource}
     * @memberof User
     */
    team?: EmbeddedResource;
}


/**
 * AccountStagesApi - fetch parameter creator
 * @export
 */
export const AccountStagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an account stage, by ID only. 
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnAccountStage.');
            }
            const localVarPath = `/v2/account_stages/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/account_stages.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountStagesApi - functional programming interface
 * @export
 */
export const AccountStagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches an account stage, by ID only. 
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountStage> {
            const localVarFetchArgs = AccountStagesApiFetchParamCreator(configuration).fetchAnAccountStage(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountStage>> {
            const localVarFetchArgs = AccountStagesApiFetchParamCreator(configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountStagesApi - factory interface
 * @export
 */
export const AccountStagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches an account stage, by ID only. 
         * @summary Fetch an account stage
         * @param {string} id Account Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountStage(id: string, options?: any) {
            return AccountStagesApiFp(configuration).fetchAnAccountStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List account stages
         * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountStages(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return AccountStagesApiFp(configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * AccountStagesApi - object-oriented interface
 * @export
 * @class AccountStagesApi
 * @extends {BaseAPI}
 */
export class AccountStagesApi extends BaseAPI {
    /**
     * Fetches an account stage, by ID only. 
     * @summary Fetch an account stage
     * @param {string} id Account Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStagesApi
     */
    public fetchAnAccountStage(id: string, options?: any) {
        return AccountStagesApiFp(this.configuration).fetchAnAccountStage(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple account stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List account stages
     * @param {Array<number>} [ids] IDs of account stages to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStagesApi
     */
    public listAccountStages(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return AccountStagesApiFp(this.configuration).listAccountStages(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * AccountTiersApi - fetch parameter creator
 * @export
 */
export const AccountTiersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an account tier, by ID only. 
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnAccountTier.');
            }
            const localVarPath = `/v2/account_tiers/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers(ids?: Array<number>, name?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/account_tiers.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTiersApi - functional programming interface
 * @export
 */
export const AccountTiersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches an account tier, by ID only. 
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountTier> {
            const localVarFetchArgs = AccountTiersApiFetchParamCreator(configuration).fetchAnAccountTier(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers(ids?: Array<number>, name?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountTier>> {
            const localVarFetchArgs = AccountTiersApiFetchParamCreator(configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountTiersApi - factory interface
 * @export
 */
export const AccountTiersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches an account tier, by ID only. 
         * @summary Fetch an account tier
         * @param {string} id Account Tier ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccountTier(id: string, options?: any) {
            return AccountTiersApiFp(configuration).fetchAnAccountTier(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List Account Tiers
         * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTiers(ids?: Array<number>, name?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return AccountTiersApiFp(configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * AccountTiersApi - object-oriented interface
 * @export
 * @class AccountTiersApi
 * @extends {BaseAPI}
 */
export class AccountTiersApi extends BaseAPI {
    /**
     * Fetches an account tier, by ID only. 
     * @summary Fetch an account tier
     * @param {string} id Account Tier ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTiersApi
     */
    public fetchAnAccountTier(id: string, options?: any) {
        return AccountTiersApiFp(this.configuration).fetchAnAccountTier(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple account tier records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List Account Tiers
     * @param {Array<number>} [ids] IDs of Account Tiers to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [name] Filters Account Tiers by name. Multiple names can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, order. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTiersApi
     */
    public listAccountTiers(ids?: Array<number>, name?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return AccountTiersApiFp(this.configuration).listAccountTiers(ids, name, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team. 
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount(name: string, domain: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createAnAccount.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling createAnAccount.');
            }
            const localVarPath = `/v2/accounts.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (domain !== undefined) {
                localVarFormParams.set('domain', domain as any);
            }

            if (conversationalName !== undefined) {
                localVarFormParams.set('conversational_name', conversationalName as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (phone !== undefined) {
                localVarFormParams.set('phone', phone as any);
            }

            if (website !== undefined) {
                localVarFormParams.set('website', website as any);
            }

            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl as any);
            }

            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle as any);
            }

            if (street !== undefined) {
                localVarFormParams.set('street', street as any);
            }

            if (city !== undefined) {
                localVarFormParams.set('city', city as any);
            }

            if (state !== undefined) {
                localVarFormParams.set('state', state as any);
            }

            if (postalCode !== undefined) {
                localVarFormParams.set('postal_code', postalCode as any);
            }

            if (country !== undefined) {
                localVarFormParams.set('country', country as any);
            }

            if (locale !== undefined) {
                localVarFormParams.set('locale', locale as any);
            }

            if (industry !== undefined) {
                localVarFormParams.set('industry', industry as any);
            }

            if (companyType !== undefined) {
                localVarFormParams.set('company_type', companyType as any);
            }

            if (founded !== undefined) {
                localVarFormParams.set('founded', founded as any);
            }

            if (revenueRange !== undefined) {
                localVarFormParams.set('revenue_range', revenueRange as any);
            }

            if (size !== undefined) {
                localVarFormParams.set('size', size as any);
            }

            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact as any);
            }

            if (customFields) {
                    localVarFormParams.set('custom_fields', customFields.join(COLLECTION_FORMATS["csv"]));
            }

            if (tags) {
                    localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS["csv"]));
            }

            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId as any);
            }

            if (companyStageId !== undefined) {
                localVarFormParams.set('company_stage_id', companyStageId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account. 
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAnAccount.');
            }
            const localVarPath = `/v2/accounts/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an account, by ID only. 
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnAccount.');
            }
            const localVarPath = `/v2/accounts/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(ids?: Array<number>, crmId?: Array<string>, tag?: Array<string>, updatedAt?: Array<string>, domain?: string, archived?: boolean, name?: Array<string>, accountStageId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/accounts.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (crmId) {
                localVarQueryParameter['crm_id'] = crmId.join(COLLECTION_FORMATS["csv"]);
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS["csv"]);
            }

            if (accountStageId) {
                localVarQueryParameter['account_stage_id'] = accountStageId.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team. 
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount(name: string, domain: string, id: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, archived?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateAnExistingAccount.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling updateAnExistingAccount.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAnExistingAccount.');
            }
            const localVarPath = `/v2/accounts/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (domain !== undefined) {
                localVarFormParams.set('domain', domain as any);
            }

            if (conversationalName !== undefined) {
                localVarFormParams.set('conversational_name', conversationalName as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (phone !== undefined) {
                localVarFormParams.set('phone', phone as any);
            }

            if (website !== undefined) {
                localVarFormParams.set('website', website as any);
            }

            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl as any);
            }

            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle as any);
            }

            if (street !== undefined) {
                localVarFormParams.set('street', street as any);
            }

            if (city !== undefined) {
                localVarFormParams.set('city', city as any);
            }

            if (state !== undefined) {
                localVarFormParams.set('state', state as any);
            }

            if (postalCode !== undefined) {
                localVarFormParams.set('postal_code', postalCode as any);
            }

            if (country !== undefined) {
                localVarFormParams.set('country', country as any);
            }

            if (locale !== undefined) {
                localVarFormParams.set('locale', locale as any);
            }

            if (industry !== undefined) {
                localVarFormParams.set('industry', industry as any);
            }

            if (companyType !== undefined) {
                localVarFormParams.set('company_type', companyType as any);
            }

            if (founded !== undefined) {
                localVarFormParams.set('founded', founded as any);
            }

            if (revenueRange !== undefined) {
                localVarFormParams.set('revenue_range', revenueRange as any);
            }

            if (size !== undefined) {
                localVarFormParams.set('size', size as any);
            }

            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact as any);
            }

            if (customFields) {
                    localVarFormParams.set('custom_fields', customFields.join(COLLECTION_FORMATS["csv"]));
            }

            if (tags) {
                    localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS["csv"]));
            }

            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId as any);
            }

            if (companyStageId !== undefined) {
                localVarFormParams.set('company_stage_id', companyStageId as any);
            }

            if (archived !== undefined) {
                localVarFormParams.set('archived', archived as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team. 
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount(name: string, domain: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account. 
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).deleteAnAccount(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an account, by ID only. 
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).fetchAnAccount(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(ids?: Array<number>, crmId?: Array<string>, tag?: Array<string>, updatedAt?: Array<string>, domain?: string, archived?: boolean, name?: Array<string>, accountStageId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team. 
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount(name: string, domain: string, id: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, archived?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an account.  \"domain\" must be unique on the current team. 
         * @summary Create an account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnAccount(name: string, domain: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, options?: any) {
            return AccountsApiFp(configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options)(fetch, basePath);
        },
        /**
         * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account. 
         * @summary Delete an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnAccount(id: string, options?: any) {
            return AccountsApiFp(configuration).deleteAnAccount(id, options)(fetch, basePath);
        },
        /**
         * Fetches an account, by ID only. 
         * @summary Fetch an account
         * @param {string} id Account ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAccount(id: string, options?: any) {
            return AccountsApiFp(configuration).fetchAnAccount(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List accounts
         * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
         * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
         * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
         * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
         * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(ids?: Array<number>, crmId?: Array<string>, tag?: Array<string>, updatedAt?: Array<string>, domain?: string, archived?: boolean, name?: Array<string>, accountStageId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return AccountsApiFp(configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates an account.  \"domain\" must be unique on the current team. 
         * @summary Update an existing Account
         * @param {string} name Account Full Name
         * @param {string} domain Website domain, not a fully qualified URI
         * @param {string} id Account ID
         * @param {string} [conversationalName] Conversational name of the Account
         * @param {string} [description] Description
         * @param {string} [phone] Phone number without formatting
         * @param {string} [website] Website
         * @param {string} [linkedinUrl] Full LinkedIn url
         * @param {string} [twitterHandle] Twitter handle, with @
         * @param {string} [street] Street name and number
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [country] Country
         * @param {string} [locale] Time locale
         * @param {string} [industry] Industry
         * @param {string} [companyType] Type of the Account&#39;s company
         * @param {string} [founded] Date or year of founding
         * @param {string} [revenueRange] Estimated revenue range
         * @param {string} [size] Estimated number of people in employment
         * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {Array<string>} [tags] All tags applied to this Account
         * @param {number} [ownerId] ID of the User that owns this Account
         * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
         * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnExistingAccount(name: string, domain: string, id: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, archived?: boolean, options?: any) {
            return AccountsApiFp(configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options)(fetch, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates an account.  \"domain\" must be unique on the current team. 
     * @summary Create an account
     * @param {string} name Account Full Name
     * @param {string} domain Website domain, not a fully qualified URI
     * @param {string} [conversationalName] Conversational name of the Account
     * @param {string} [description] Description
     * @param {string} [phone] Phone number without formatting
     * @param {string} [website] Website
     * @param {string} [linkedinUrl] Full LinkedIn url
     * @param {string} [twitterHandle] Twitter handle, with @
     * @param {string} [street] Street name and number
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [country] Country
     * @param {string} [locale] Time locale
     * @param {string} [industry] Industry
     * @param {string} [companyType] Type of the Account&#39;s company
     * @param {string} [founded] Date or year of founding
     * @param {string} [revenueRange] Estimated revenue range
     * @param {string} [size] Estimated number of people in employment
     * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {Array<string>} [tags] All tags applied to this Account
     * @param {number} [ownerId] ID of the User that owns this Account
     * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAnAccount(name: string, domain: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, options?: any) {
        return AccountsApiFp(this.configuration).createAnAccount(name, domain, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an account. This operation is not reversible without contacting support. This operation can be called multiple times successfully.  Deleting an account will remove all connected people from that account. 
     * @summary Delete an account
     * @param {string} id Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAnAccount(id: string, options?: any) {
        return AccountsApiFp(this.configuration).deleteAnAccount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches an account, by ID only. 
     * @summary Fetch an account
     * @param {string} id Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public fetchAnAccount(id: string, options?: any) {
        return AccountsApiFp(this.configuration).fetchAnAccount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple account records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List accounts
     * @param {Array<number>} [ids] IDs of accounts to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [crmId] Filters accounts by crm_id. Multiple crm ids can be applied
     * @param {Array<string>} [tag] Filters accounts by the tags applied to the account. Multiple tags can be applied
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [domain] Domain of the accounts to fetch. Domains are unique and lowercase
     * @param {boolean} [archived] Filters accounts by archived_at status. Returns only accounts where archived_at is not null if this field is true. Returns only accounts where archived_at is null if this field is false. Do not pass this parameter to return both archived and unarchived accounts. This filter is not applied if any value other than \&quot;true\&quot; or \&quot;false\&quot; is passed.
     * @param {Array<string>} [name] Names of accounts to fetch. Name matches are exact and case sensitive. Multiple names can be fetched.
     * @param {Array<number>} [accountStageId] Filters accounts by account_stage_id. Multiple account_stage_ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at, account_stage, account_tier. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(ids?: Array<number>, crmId?: Array<string>, tag?: Array<string>, updatedAt?: Array<string>, domain?: string, archived?: boolean, name?: Array<string>, accountStageId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return AccountsApiFp(this.configuration).listAccounts(ids, crmId, tag, updatedAt, domain, archived, name, accountStageId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an account.  \"domain\" must be unique on the current team. 
     * @summary Update an existing Account
     * @param {string} name Account Full Name
     * @param {string} domain Website domain, not a fully qualified URI
     * @param {string} id Account ID
     * @param {string} [conversationalName] Conversational name of the Account
     * @param {string} [description] Description
     * @param {string} [phone] Phone number without formatting
     * @param {string} [website] Website
     * @param {string} [linkedinUrl] Full LinkedIn url
     * @param {string} [twitterHandle] Twitter handle, with @
     * @param {string} [street] Street name and number
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [country] Country
     * @param {string} [locale] Time locale
     * @param {string} [industry] Industry
     * @param {string} [companyType] Type of the Account&#39;s company
     * @param {string} [founded] Date or year of founding
     * @param {string} [revenueRange] Estimated revenue range
     * @param {string} [size] Estimated number of people in employment
     * @param {boolean} [doNotContact] Whether this company can not be contacted. Values are either true or false. Setting this to true will remove all associated people from all active communications
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {Array<string>} [tags] All tags applied to this Account
     * @param {number} [ownerId] ID of the User that owns this Account
     * @param {number} [companyStageId] ID of the CompanyStage assigned to this Account
     * @param {boolean} [archived] Whether this Account should be archived or not. Setting this to true sets archived_at to the current time if it&#39;s not already set. Setting this to false will set archived_at to null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAnExistingAccount(name: string, domain: string, id: string, conversationalName?: string, description?: string, phone?: string, website?: string, linkedinUrl?: string, twitterHandle?: string, street?: string, city?: string, state?: string, postalCode?: string, country?: string, locale?: string, industry?: string, companyType?: string, founded?: string, revenueRange?: string, size?: string, doNotContact?: boolean, customFields?: Array<string>, tags?: Array<string>, ownerId?: number, companyStageId?: number, archived?: boolean, options?: any) {
        return AccountsApiFp(this.configuration).updateAnExistingAccount(name, domain, id, conversationalName, description, phone, website, linkedinUrl, twitterHandle, street, city, state, postalCode, country, locale, industry, companyType, founded, revenueRange, size, doNotContact, customFields, tags, ownerId, companyStageId, archived, options)(this.fetch, this.basePath);
    }

}

/**
 * ActionDetailsCallInstructionsApi - fetch parameter creator
 * @export
 */
export const ActionDetailsCallInstructionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a call instruction, by ID only. 
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACallInstructions.');
            }
            const localVarPath = `/v2/action_details/call_instructions/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/action_details/call_instructions.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionDetailsCallInstructionsApi - functional programming interface
 * @export
 */
export const ActionDetailsCallInstructionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a call instruction, by ID only. 
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CallInstruction> {
            const localVarFetchArgs = ActionDetailsCallInstructionsApiFetchParamCreator(configuration).fetchACallInstructions(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CallInstruction>> {
            const localVarFetchArgs = ActionDetailsCallInstructionsApiFetchParamCreator(configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActionDetailsCallInstructionsApi - factory interface
 * @export
 */
export const ActionDetailsCallInstructionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a call instruction, by ID only. 
         * @summary Fetch a call instructions
         * @param {string} id Call instructions ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallInstructions(id: string, options?: any) {
            return ActionDetailsCallInstructionsApiFp(configuration).fetchACallInstructions(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List call instructions
         * @param {Array<number>} [ids] IDs of call instructions to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallInstructions(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return ActionDetailsCallInstructionsApiFp(configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * ActionDetailsCallInstructionsApi - object-oriented interface
 * @export
 * @class ActionDetailsCallInstructionsApi
 * @extends {BaseAPI}
 */
export class ActionDetailsCallInstructionsApi extends BaseAPI {
    /**
     * Fetches a call instruction, by ID only. 
     * @summary Fetch a call instructions
     * @param {string} id Call instructions ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionDetailsCallInstructionsApi
     */
    public fetchACallInstructions(id: string, options?: any) {
        return ActionDetailsCallInstructionsApiFp(this.configuration).fetchACallInstructions(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List call instructions
     * @param {Array<number>} [ids] IDs of call instructions to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionDetailsCallInstructionsApi
     */
    public listCallInstructions(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return ActionDetailsCallInstructionsApiFp(this.configuration).listCallInstructions(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * ActionsApi - fetch parameter creator
 * @export
 */
export const ActionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code. 
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnAction.');
            }
            const localVarPath = `/v2/actions/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter. 
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions(ids?: Array<number>, stepId?: number, type?: string, dueOn?: Array<string>, userGuid?: Array<string>, personId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/actions.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (stepId !== undefined) {
                localVarQueryParameter['step_id'] = stepId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (dueOn) {
                localVarQueryParameter['due_on'] = dueOn.join(COLLECTION_FORMATS["csv"]);
            }

            if (userGuid) {
                localVarQueryParameter['user_guid'] = userGuid.join(COLLECTION_FORMATS["csv"]);
            }

            if (personId) {
                localVarQueryParameter['person_id'] = personId.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code. 
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Action> {
            const localVarFetchArgs = ActionsApiFetchParamCreator(configuration).fetchAnAction(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter. 
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions(ids?: Array<number>, stepId?: number, type?: string, dueOn?: Array<string>, userGuid?: Array<string>, personId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Action>> {
            const localVarFetchArgs = ActionsApiFetchParamCreator(configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code. 
         * @summary Fetch an action
         * @param {string} id Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnAction(id: string, options?: any) {
            return ActionsApiFp(configuration).fetchAnAction(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter. 
         * @summary List actions
         * @param {Array<number>} [ids] IDs of actions to fetch.
         * @param {number} [stepId] Fetch actions by step ID
         * @param {string} [type] Filter actions by type
         * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
         * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActions(ids?: Array<number>, stepId?: number, type?: string, dueOn?: Array<string>, userGuid?: Array<string>, personId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return ActionsApiFp(configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Fetches an action, by ID only. This endpoint will only return actions that are in_progress or pending_activity. Once an action is complete, the request for that action will return a 404 status code. 
     * @summary Fetch an action
     * @param {string} id Action ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public fetchAnAction(id: string, options?: any) {
        return ActionsApiFp(this.configuration).fetchAnAction(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple action records. The records can be filtered, paged, and sorted according to the respective parameters. Only actions that are currently \"in_progess\" will be returned by this endpoint.  By default, only the requesting user's actions will be returned by this endpoint. It is possible for team admin users to request other users' actions by passing the user_guid parameter. 
     * @summary List actions
     * @param {Array<number>} [ids] IDs of actions to fetch.
     * @param {number} [stepId] Fetch actions by step ID
     * @param {string} [type] Filter actions by type
     * @param {Array<string>} [dueOn] Equality filters that are applied to the due_on field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {Array<string>} [userGuid] Filters actions by the user&#39;s guid. Multiple user guids can be applied. The user must be a team admin to filter other users&#39; actions
     * @param {Array<number>} [personId] Filters actions by person_id. Multiple person ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActions(ids?: Array<number>, stepId?: number, type?: string, dueOn?: Array<string>, userGuid?: Array<string>, personId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return ActionsApiFp(this.configuration).listActions(ids, stepId, type, dueOn, userGuid, personId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them. 
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity(actionId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/activities.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them. 
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity(actionId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activity> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).createAnActivity(actionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them. 
         * @summary Create an activity
         * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActivity(actionId?: number, options?: any) {
            return ActivitiesApiFp(configuration).createAnActivity(actionId, options)(fetch, basePath);
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Creates an activity. An activity will mark the associated action as completed. Currently, only certain action types can have an activity explicitly created for them. 
     * @summary Create an activity
     * @param {number} [actionId] Action that is being completed. This will validate that the action is still valid before completed it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;integration&#39;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public createAnActivity(actionId?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).createAnActivity(actionId, options)(this.fetch, this.basePath);
    }

}

/**
 * CRMActivitiesApi - fetch parameter creator
 * @export
 */
export const CRMActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a crm activity, by ID only. 
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACrmActivity.');
            }
            const localVarPath = `/v2/crm_activities/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/crm_activities.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CRMActivitiesApi - functional programming interface
 * @export
 */
export const CRMActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a crm activity, by ID only. 
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrmActivity> {
            const localVarFetchArgs = CRMActivitiesApiFetchParamCreator(configuration).fetchACrmActivity(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CrmActivity>> {
            const localVarFetchArgs = CRMActivitiesApiFetchParamCreator(configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CRMActivitiesApi - factory interface
 * @export
 */
export const CRMActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a crm activity, by ID only. 
         * @summary Fetch a crm activity
         * @param {string} id Crm activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACrmActivity(id: string, options?: any) {
            return CRMActivitiesApiFp(configuration).fetchACrmActivity(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activities
         * @param {Array<number>} [ids] IDs of crm activities to fetch.
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivities(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CRMActivitiesApiFp(configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CRMActivitiesApi - object-oriented interface
 * @export
 * @class CRMActivitiesApi
 * @extends {BaseAPI}
 */
export class CRMActivitiesApi extends BaseAPI {
    /**
     * Fetches a crm activity, by ID only. 
     * @summary Fetch a crm activity
     * @param {string} id Crm activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivitiesApi
     */
    public fetchACrmActivity(id: string, options?: any) {
        return CRMActivitiesApiFp(this.configuration).fetchACrmActivity(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List crm activities
     * @param {Array<number>} [ids] IDs of crm activities to fetch.
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivitiesApi
     */
    public listCrmActivities(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CRMActivitiesApiFp(this.configuration).listCrmActivities(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CRMActivityFieldsApi - fetch parameter creator
 * @export
 */
export const CRMActivityFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields(source?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/crm_activity_fields.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CRMActivityFieldsApi - functional programming interface
 * @export
 */
export const CRMActivityFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields(source?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CrmActivityField>> {
            const localVarFetchArgs = CRMActivityFieldsApiFetchParamCreator(configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CRMActivityFieldsApi - factory interface
 * @export
 */
export const CRMActivityFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List crm activity fields
         * @param {string} [source] Return only records with this source
         * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrmActivityFields(source?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CRMActivityFieldsApiFp(configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CRMActivityFieldsApi - object-oriented interface
 * @export
 * @class CRMActivityFieldsApi
 * @extends {BaseAPI}
 */
export class CRMActivityFieldsApi extends BaseAPI {
    /**
     * Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List crm activity fields
     * @param {string} [source] Return only records with this source
     * @param {string} [sortBy] Key to sort on, must be one of: title, updated_at. Defaults to title
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMActivityFieldsApi
     */
    public listCrmActivityFields(source?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CRMActivityFieldsApiFp(this.configuration).listCrmActivityFields(source, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CadenceMembershipsApi - fetch parameter creator
 * @export
 */
export const CadenceMembershipsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate. 
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership(personId: number, cadenceId: number, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling createACadenceMembership.');
            }
            // verify required parameter 'cadenceId' is not null or undefined
            if (cadenceId === null || cadenceId === undefined) {
                throw new RequiredError('cadenceId','Required parameter cadenceId was null or undefined when calling createACadenceMembership.');
            }
            const localVarPath = `/v2/cadence_memberships.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (personId !== undefined) {
                localVarQueryParameter['person_id'] = personId;
            }

            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteACadenceMembership.');
            }
            const localVarPath = `/v2/cadence_memberships/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a cadence membership, by ID only. 
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACadenceMembership.');
            }
            const localVarPath = `/v2/cadence_memberships/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record. 
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships(ids?: Array<number>, personId?: number, cadenceId?: number, updatedAt?: Array<string>, currentlyOnCadence?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/cadence_memberships.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (personId !== undefined) {
                localVarQueryParameter['person_id'] = personId;
            }

            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (currentlyOnCadence !== undefined) {
                localVarQueryParameter['currently_on_cadence'] = currentlyOnCadence;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CadenceMembershipsApi - functional programming interface
 * @export
 */
export const CadenceMembershipsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate. 
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership(personId: number, cadenceId: number, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CadenceMembership> {
            const localVarFetchArgs = CadenceMembershipsApiFetchParamCreator(configuration).createACadenceMembership(personId, cadenceId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CadenceMembershipsApiFetchParamCreator(configuration).deleteACadenceMembership(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a cadence membership, by ID only. 
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CadenceMembership> {
            const localVarFetchArgs = CadenceMembershipsApiFetchParamCreator(configuration).fetchACadenceMembership(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record. 
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships(ids?: Array<number>, personId?: number, cadenceId?: number, updatedAt?: Array<string>, currentlyOnCadence?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CadenceMembership>> {
            const localVarFetchArgs = CadenceMembershipsApiFetchParamCreator(configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CadenceMembershipsApi - factory interface
 * @export
 */
export const CadenceMembershipsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate. 
         * @summary Create a cadence membership
         * @param {number} personId ID of the person to create a cadence membership for
         * @param {number} cadenceId ID of the cadence to create a cadence membership for
         * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACadenceMembership(personId: number, cadenceId: number, userId?: number, options?: any) {
            return CadenceMembershipsApiFp(configuration).createACadenceMembership(personId, cadenceId, userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACadenceMembership(id: string, options?: any) {
            return CadenceMembershipsApiFp(configuration).deleteACadenceMembership(id, options)(fetch, basePath);
        },
        /**
         * Fetches a cadence membership, by ID only. 
         * @summary Fetch a cadence membership
         * @param {string} id CadenceMembership ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadenceMembership(id: string, options?: any) {
            return CadenceMembershipsApiFp(configuration).fetchACadenceMembership(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record. 
         * @summary List cadence memberships
         * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {number} [personId] ID of the person to find cadence memberships for
         * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
         * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadenceMemberships(ids?: Array<number>, personId?: number, cadenceId?: number, updatedAt?: Array<string>, currentlyOnCadence?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CadenceMembershipsApiFp(configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CadenceMembershipsApi - object-oriented interface
 * @export
 * @class CadenceMembershipsApi
 * @extends {BaseAPI}
 */
export class CadenceMembershipsApi extends BaseAPI {
    /**
     * Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will default to the authenticated user, but can be set to any visible user on the authenticated team.  A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, or the cadence is owned by the teammate. 
     * @summary Create a cadence membership
     * @param {number} personId ID of the person to create a cadence membership for
     * @param {number} cadenceId ID of the cadence to create a cadence membership for
     * @param {number} [userId] ID of the user to create a cadence membership for. The associated cadence must be owned by the user, or it must be a team cadence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    public createACadenceMembership(personId: number, cadenceId: number, userId?: number, options?: any) {
        return CadenceMembershipsApiFp(this.configuration).createACadenceMembership(personId, cadenceId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a cadence membership
     * @param {string} id CadenceMembership ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    public deleteACadenceMembership(id: string, options?: any) {
        return CadenceMembershipsApiFp(this.configuration).deleteACadenceMembership(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a cadence membership, by ID only. 
     * @summary Fetch a cadence membership
     * @param {string} id CadenceMembership ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    public fetchACadenceMembership(id: string, options?: any) {
        return CadenceMembershipsApiFp(this.configuration).fetchACadenceMembership(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to the respective parameters. A cadence membership is the association between a person and their current and historical time on a cadence. Cadence membership records are mutable and change over time. If a person is added to a cadence and re-added to the same cadence in the future, there is a single membership record. 
     * @summary List cadence memberships
     * @param {Array<number>} [ids] IDs of cadence memberships to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {number} [personId] ID of the person to find cadence memberships for
     * @param {number} [cadenceId] ID of the cadence to find cadence memberships for
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {boolean} [currentlyOnCadence] If true, return only cadence memberships for people currently on cadences.  If false, return cadence memberships for people who have been removed from or have completed a cadence.
     * @param {string} [sortBy] Key to sort on, must be one of: added_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadenceMembershipsApi
     */
    public listCadenceMemberships(ids?: Array<number>, personId?: number, cadenceId?: number, updatedAt?: Array<string>, currentlyOnCadence?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CadenceMembershipsApiFp(this.configuration).listCadenceMemberships(ids, personId, cadenceId, updatedAt, currentlyOnCadence, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CadencesApi - fetch parameter creator
 * @export
 */
export const CadencesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a cadence, by ID only. 
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACadence.');
            }
            const localVarPath = `/v2/cadences/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences(ids?: Array<number>, updatedAt?: Array<string>, teamCadence?: boolean, shared?: boolean, ownedByGuid?: Array<string>, peopleAddable?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/cadences.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (teamCadence !== undefined) {
                localVarQueryParameter['team_cadence'] = teamCadence;
            }

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (ownedByGuid) {
                localVarQueryParameter['owned_by_guid'] = ownedByGuid.join(COLLECTION_FORMATS["csv"]);
            }

            if (peopleAddable !== undefined) {
                localVarQueryParameter['people_addable'] = peopleAddable;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CadencesApi - functional programming interface
 * @export
 */
export const CadencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a cadence, by ID only. 
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cadence> {
            const localVarFetchArgs = CadencesApiFetchParamCreator(configuration).fetchACadence(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences(ids?: Array<number>, updatedAt?: Array<string>, teamCadence?: boolean, shared?: boolean, ownedByGuid?: Array<string>, peopleAddable?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cadence>> {
            const localVarFetchArgs = CadencesApiFetchParamCreator(configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CadencesApi - factory interface
 * @export
 */
export const CadencesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a cadence, by ID only. 
         * @summary Fetch a cadence
         * @param {string} id Cadence ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACadence(id: string, options?: any) {
            return CadencesApiFp(configuration).fetchACadence(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List cadences
         * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
         * @param {boolean} [shared] Filters cadences by whether they are shared
         * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCadences(ids?: Array<number>, updatedAt?: Array<string>, teamCadence?: boolean, shared?: boolean, ownedByGuid?: Array<string>, peopleAddable?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CadencesApiFp(configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CadencesApi - object-oriented interface
 * @export
 * @class CadencesApi
 * @extends {BaseAPI}
 */
export class CadencesApi extends BaseAPI {
    /**
     * Fetches a cadence, by ID only. 
     * @summary Fetch a cadence
     * @param {string} id Cadence ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadencesApi
     */
    public fetchACadence(id: string, options?: any) {
        return CadencesApiFp(this.configuration).fetchACadence(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple cadence records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List cadences
     * @param {Array<number>} [ids] IDs of cadences to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {boolean} [teamCadence] Filters cadences by whether they are a team cadence or not
     * @param {boolean} [shared] Filters cadences by whether they are shared
     * @param {Array<string>} [ownedByGuid] Filters cadences by the owner&#39;s guid. Multiple owner guids can be applied
     * @param {boolean} [peopleAddable] Filters cadences by whether they are able to have people added to them
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CadencesApi
     */
    public listCadences(ids?: Array<number>, updatedAt?: Array<string>, teamCadence?: boolean, shared?: boolean, ownedByGuid?: Array<string>, peopleAddable?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CadencesApiFp(this.configuration).listCadences(ids, updatedAt, teamCadence, shared, ownedByGuid, peopleAddable, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CallDataRecordsApi - fetch parameter creator
 * @export
 */
export const CallDataRecordsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a call data record, by ID only. 
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACallDataRecord.');
            }
            const localVarPath = `/v2/call_data_records/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be. 
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords(ids?: Array<number>, hasCall?: boolean, createdAt?: Array<string>, updatedAt?: Array<string>, userGuid?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/call_data_records.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (hasCall !== undefined) {
                localVarQueryParameter['has_call'] = hasCall;
            }

            if (createdAt) {
                localVarQueryParameter['created_at'] = createdAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (userGuid) {
                localVarQueryParameter['user_guid'] = userGuid.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallDataRecordsApi - functional programming interface
 * @export
 */
export const CallDataRecordsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a call data record, by ID only. 
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CallDataRecord> {
            const localVarFetchArgs = CallDataRecordsApiFetchParamCreator(configuration).fetchACallDataRecord(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be. 
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords(ids?: Array<number>, hasCall?: boolean, createdAt?: Array<string>, updatedAt?: Array<string>, userGuid?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CallDataRecord>> {
            const localVarFetchArgs = CallDataRecordsApiFetchParamCreator(configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallDataRecordsApi - factory interface
 * @export
 */
export const CallDataRecordsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a call data record, by ID only. 
         * @summary Fetch a call data record
         * @param {string} id CallDataRecord ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACallDataRecord(id: string, options?: any) {
            return CallDataRecordsApiFp(configuration).fetchACallDataRecord(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be. 
         * @summary List call data records
         * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
         * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [userGuid] Filters list to only include guids
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDataRecords(ids?: Array<number>, hasCall?: boolean, createdAt?: Array<string>, updatedAt?: Array<string>, userGuid?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CallDataRecordsApiFp(configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CallDataRecordsApi - object-oriented interface
 * @export
 * @class CallDataRecordsApi
 * @extends {BaseAPI}
 */
export class CallDataRecordsApi extends BaseAPI {
    /**
     * Fetches a call data record, by ID only. 
     * @summary Fetch a call data record
     * @param {string} id CallDataRecord ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDataRecordsApi
     */
    public fetchACallDataRecord(id: string, options?: any) {
        return CallDataRecordsApiFp(this.configuration).fetchACallDataRecord(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple call data records. The records can be filtered, paged, and sorted according to the respective parameters.  Call data records are records of all inbound and outbound calls through SalesLoft. A call data record may be associated with a call, but does not have to be. 
     * @summary List call data records
     * @param {Array<number>} [ids] IDs of call data records to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {boolean} [hasCall] Return only call data records which have or do not have a call logged for them
     * @param {Array<string>} [createdAt] Equality filters that are applied to the created_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {Array<string>} [userGuid] Filters list to only include guids
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDataRecordsApi
     */
    public listCallDataRecords(ids?: Array<number>, hasCall?: boolean, createdAt?: Array<string>, updatedAt?: Array<string>, userGuid?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CallDataRecordsApiFp(this.configuration).listCallDataRecords(ids, hasCall, createdAt, updatedAt, userGuid, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CallDispositionsApi - fetch parameter creator
 * @export
 */
export const CallDispositionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/call_dispositions.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallDispositionsApi - functional programming interface
 * @export
 */
export const CallDispositionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CallDisposition>> {
            const localVarFetchArgs = CallDispositionsApiFetchParamCreator(configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallDispositionsApi - factory interface
 * @export
 */
export const CallDispositionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call dispositions
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallDispositions(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CallDispositionsApiFp(configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CallDispositionsApi - object-oriented interface
 * @export
 * @class CallDispositionsApi
 * @extends {BaseAPI}
 */
export class CallDispositionsApi extends BaseAPI {
    /**
     * Fetches multiple call disposition records. The records can be sorted according to the respective parameters. Call dispositions must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
     * @summary List call dispositions
     * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallDispositionsApi
     */
    public listCallDispositions(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CallDispositionsApiFp(this.configuration).listCallDispositions(sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CallSentimentsApi - fetch parameter creator
 * @export
 */
export const CallSentimentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/call_sentiments.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallSentimentsApi - functional programming interface
 * @export
 */
export const CallSentimentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CallDisposition>> {
            const localVarFetchArgs = CallSentimentsApiFetchParamCreator(configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallSentimentsApi - factory interface
 * @export
 */
export const CallSentimentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
         * @summary List call sentiments
         * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallSentiments(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CallSentimentsApiFp(configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CallSentimentsApi - object-oriented interface
 * @export
 * @class CallSentimentsApi
 * @extends {BaseAPI}
 */
export class CallSentimentsApi extends BaseAPI {
    /**
     * Fetches multiple call sentiment records. The records can be sorted according to the respective parameters. Call sentiments must be configured in application. This will change in the future, but please contact us if you have a pressing use case. 
     * @summary List call sentiments
     * @param {string} [sortBy] Key to sort on, must be one of: name, updated_at. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to ASC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallSentimentsApi
     */
    public listCallSentiments(sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CallSentimentsApiFp(this.configuration).listCallSentiments(sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CallerIDsApi - fetch parameter creator
 * @export
 */
export const CallerIDsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format. 
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds(phoneNumber: string, options: any = {}): FetchArgs {
            // verify required parameter 'phoneNumber' is not null or undefined
            if (phoneNumber === null || phoneNumber === undefined) {
                throw new RequiredError('phoneNumber','Required parameter phoneNumber was null or undefined when calling listCallerIds.');
            }
            const localVarPath = `/v2/phone_numbers/caller_ids.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phone_number'] = phoneNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallerIDsApi - functional programming interface
 * @export
 */
export const CallerIDsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format. 
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds(phoneNumber: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CallerId>> {
            const localVarFetchArgs = CallerIDsApiFetchParamCreator(configuration).listCallerIds(phoneNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallerIDsApi - factory interface
 * @export
 */
export const CallerIDsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format. 
         * @summary List caller ids
         * @param {string} phoneNumber E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallerIds(phoneNumber: string, options?: any) {
            return CallerIDsApiFp(configuration).listCallerIds(phoneNumber, options)(fetch, basePath);
        },
    };
};

/**
 * CallerIDsApi - object-oriented interface
 * @export
 * @class CallerIDsApi
 * @extends {BaseAPI}
 */
export class CallerIDsApi extends BaseAPI {
    /**
     * Each entry is a possible caller ID match for the number. Multiple entries may be returned if the phone number is present on more than one person in the system.  Phone number should be in E.164 format. 
     * @summary List caller ids
     * @param {string} phoneNumber E.164 Phone Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallerIDsApi
     */
    public listCallerIds(phoneNumber: string, options?: any) {
        return CallerIDsApiFp(this.configuration).listCallerIds(phoneNumber, options)(this.fetch, this.basePath);
    }

}

/**
 * CallsApi - fetch parameter creator
 * @export
 */
export const CallsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly. 
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;. 
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied. 
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall(personId: number, to?: string, duration?: number, disposition?: string, sentiment?: string, notes?: string, userGuid?: string, actionId?: number, crmParams?: { [key: string]: string; }, linkedCallDataRecordIds?: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling createACall.');
            }
            const localVarPath = `/v2/activities/calls.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (personId !== undefined) {
                localVarFormParams.set('person_id', personId as any);
            }

            if (to !== undefined) {
                localVarFormParams.set('to', to as any);
            }

            if (duration !== undefined) {
                localVarFormParams.set('duration', duration as any);
            }

            if (disposition !== undefined) {
                localVarFormParams.set('disposition', disposition as any);
            }

            if (sentiment !== undefined) {
                localVarFormParams.set('sentiment', sentiment as any);
            }

            if (notes !== undefined) {
                localVarFormParams.set('notes', notes as any);
            }

            if (userGuid !== undefined) {
                localVarFormParams.set('user_guid', userGuid as any);
            }

            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId as any);
            }

            if (crmParams !== undefined) {
                localVarFormParams.set('crm_params', crmParams as any);
            }

            if (linkedCallDataRecordIds) {
                    localVarFormParams.set('linked_call_data_record_ids', linkedCallDataRecordIds.join(COLLECTION_FORMATS["csv"]));
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a call, by ID only. 
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACall.');
            }
            const localVarPath = `/v2/activities/calls/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/activities/calls.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallsApi - functional programming interface
 * @export
 */
export const CallsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly. 
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;. 
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied. 
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall(personId: number, to?: string, duration?: number, disposition?: string, sentiment?: string, notes?: string, userGuid?: string, actionId?: number, crmParams?: { [key: string]: string; }, linkedCallDataRecordIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Call> {
            const localVarFetchArgs = CallsApiFetchParamCreator(configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a call, by ID only. 
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Call> {
            const localVarFetchArgs = CallsApiFetchParamCreator(configuration).fetchACall(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Call>> {
            const localVarFetchArgs = CallsApiFetchParamCreator(configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallsApi - factory interface
 * @export
 */
export const CallsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly. 
         * @summary Create a call
         * @param {number} personId The ID of the person whom this call will be logged for
         * @param {string} [to] The phone number that was called
         * @param {number} [duration] The length of the call, in seconds
         * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
         * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
         * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
         * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
         * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;. 
         * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied. 
         * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACall(personId: number, to?: string, duration?: number, disposition?: string, sentiment?: string, notes?: string, userGuid?: string, actionId?: number, crmParams?: { [key: string]: string; }, linkedCallDataRecordIds?: Array<number>, options?: any) {
            return CallsApiFp(configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options)(fetch, basePath);
        },
        /**
         * Fetches a call, by ID only. 
         * @summary Fetch a call
         * @param {string} id Call ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACall(id: string, options?: any) {
            return CallsApiFp(configuration).fetchACall(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List calls
         * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalls(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CallsApiFp(configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * CallsApi - object-oriented interface
 * @export
 * @class CallsApi
 * @extends {BaseAPI}
 */
export class CallsApi extends BaseAPI {
    /**
     * Creates a call. The parameters of this endpoint can be used to create an action and ensure that the CRM Task is mapped correctly. 
     * @summary Create a call
     * @param {number} personId The ID of the person whom this call will be logged for
     * @param {string} [to] The phone number that was called
     * @param {number} [duration] The length of the call, in seconds
     * @param {string} [disposition] The disposition of the call. Can be required on a per-team basis. Must be present in the disposition list.
     * @param {string} [sentiment] The sentiment of the call. Can be required on a per-team basis. Must be present in the sentiment list.
     * @param {string} [notes] Notes to log for the call. This is similar to the notes endpoint, but ensures that the notes get synced to the user&#39;s CRM
     * @param {string} [userGuid] Guid of the user whom this call should be logged for. Defaults to the authenticated user. Only team admins can pass another user&#39;s guid
     * @param {number} [actionId] Action that this call is being logged for. This will validate that the action is still valid before completing it. The same action can never be successfully passed twice to this endpoint. The action must have a type of &#39;phone&#39;. 
     * @param {{ [key: string]: string; }} [crmParams] CRM specific parameters. Some parameters are required on a per-team basis. Consume the CrmActivityFields endpoint to receive a list of valid parameters. The \&quot;field\&quot; property is passed as the key of this object, and the value of this object is the value that you would like to set.  If CrmActivityField has a non-null value, then that value must be submitted, or excluded from API calls, as these values are automatically applied. 
     * @param {Array<number>} [linkedCallDataRecordIds] CallDataRecord associations that will become linked to the created call. It is possible to pass multiple CallDataRecord ids in this field; this can be used to represent multiple phone calls that made up a single call.  Any call data record that is used must not already be linked to a call. It is not possible to link a call data record to multiple calls, and it is not possible to re-assign a call data record to a different call. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    public createACall(personId: number, to?: string, duration?: number, disposition?: string, sentiment?: string, notes?: string, userGuid?: string, actionId?: number, crmParams?: { [key: string]: string; }, linkedCallDataRecordIds?: Array<number>, options?: any) {
        return CallsApiFp(this.configuration).createACall(personId, to, duration, disposition, sentiment, notes, userGuid, actionId, crmParams, linkedCallDataRecordIds, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a call, by ID only. 
     * @summary Fetch a call
     * @param {string} id Call ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    public fetchACall(id: string, options?: any) {
        return CallsApiFp(this.configuration).fetchACall(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple call records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List calls
     * @param {Array<number>} [ids] IDs of calls to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    public listCalls(ids?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CallsApiFp(this.configuration).listCalls(ids, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomFieldsApi - fetch parameter creator
 * @export
 */
export const CustomFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a custom field. 
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField(name: string, fieldType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createACustomField.');
            }
            const localVarPath = `/v2/custom_fields.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (fieldType !== undefined) {
                localVarFormParams.set('field_type', fieldType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom field. 
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteACustomField.');
            }
            const localVarPath = `/v2/custom_fields/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a custom field, by ID only. 
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchACustomField.');
            }
            const localVarPath = `/v2/custom_fields/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields(ids?: Array<number>, fieldType?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/custom_fields.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (fieldType !== undefined) {
                localVarQueryParameter['field_type'] = fieldType;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a custom field. 
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField(id: string, name?: string, fieldType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateACustomField.');
            }
            const localVarPath = `/v2/custom_fields/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (fieldType !== undefined) {
                localVarFormParams.set('field_type', fieldType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFieldsApi - functional programming interface
 * @export
 */
export const CustomFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a custom field. 
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField(name: string, fieldType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomField> {
            const localVarFetchArgs = CustomFieldsApiFetchParamCreator(configuration).createACustomField(name, fieldType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a custom field. 
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomFieldsApiFetchParamCreator(configuration).deleteACustomField(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a custom field, by ID only. 
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomField> {
            const localVarFetchArgs = CustomFieldsApiFetchParamCreator(configuration).fetchACustomField(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields(ids?: Array<number>, fieldType?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomField>> {
            const localVarFetchArgs = CustomFieldsApiFetchParamCreator(configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a custom field. 
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField(id: string, name?: string, fieldType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomField> {
            const localVarFetchArgs = CustomFieldsApiFetchParamCreator(configuration).updateACustomField(id, name, fieldType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomFieldsApi - factory interface
 * @export
 */
export const CustomFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a custom field. 
         * @summary Create a custom field
         * @param {string} name The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACustomField(name: string, fieldType?: string, options?: any) {
            return CustomFieldsApiFp(configuration).createACustomField(name, fieldType, options)(fetch, basePath);
        },
        /**
         * Deletes a custom field. 
         * @summary Delete a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACustomField(id: string, options?: any) {
            return CustomFieldsApiFp(configuration).deleteACustomField(id, options)(fetch, basePath);
        },
        /**
         * Fetches a custom field, by ID only. 
         * @summary Fetch a custom field
         * @param {string} id Custom Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchACustomField(id: string, options?: any) {
            return CustomFieldsApiFp(configuration).fetchACustomField(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List custom fields
         * @param {Array<number>} [ids] IDs of custom fields to fetch.
         * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields(ids?: Array<number>, fieldType?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return CustomFieldsApiFp(configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Update a custom field. 
         * @summary Update a custom field
         * @param {string} id Custom Field ID
         * @param {string} [name] The name of the custom field
         * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACustomField(id: string, name?: string, fieldType?: string, options?: any) {
            return CustomFieldsApiFp(configuration).updateACustomField(id, name, fieldType, options)(fetch, basePath);
        },
    };
};

/**
 * CustomFieldsApi - object-oriented interface
 * @export
 * @class CustomFieldsApi
 * @extends {BaseAPI}
 */
export class CustomFieldsApi extends BaseAPI {
    /**
     * Creates a custom field. 
     * @summary Create a custom field
     * @param {string} name The name of the custom field
     * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    public createACustomField(name: string, fieldType?: string, options?: any) {
        return CustomFieldsApiFp(this.configuration).createACustomField(name, fieldType, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a custom field. 
     * @summary Delete a custom field
     * @param {string} id Custom Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    public deleteACustomField(id: string, options?: any) {
        return CustomFieldsApiFp(this.configuration).deleteACustomField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a custom field, by ID only. 
     * @summary Fetch a custom field
     * @param {string} id Custom Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    public fetchACustomField(id: string, options?: any) {
        return CustomFieldsApiFp(this.configuration).fetchACustomField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple custom field records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List custom fields
     * @param {Array<number>} [ids] IDs of custom fields to fetch.
     * @param {string} [fieldType] Type of field to fetch. Value must be one of: person, company, opportunity
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, name. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    public listCustomFields(ids?: Array<number>, fieldType?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return CustomFieldsApiFp(this.configuration).listCustomFields(ids, fieldType, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Update a custom field. 
     * @summary Update a custom field
     * @param {string} id Custom Field ID
     * @param {string} [name] The name of the custom field
     * @param {string} [fieldType] The field type of the custom field. Value must be one of: person, company, opportunity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldsApi
     */
    public updateACustomField(id: string, name?: string, fieldType?: string, options?: any) {
        return CustomFieldsApiFp(this.configuration).updateACustomField(id, name, fieldType, options)(this.fetch, this.basePath);
    }

}

/**
 * EmailTemplateAttachmentsApi - fetch parameter creator
 * @export
 */
export const EmailTemplateAttachmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments(ids?: Array<number>, emailTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/email_template_attachments.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (emailTemplateId) {
                localVarQueryParameter['email_template_id'] = emailTemplateId.join(COLLECTION_FORMATS["csv"]);
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailTemplateAttachmentsApi - functional programming interface
 * @export
 */
export const EmailTemplateAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments(ids?: Array<number>, emailTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EmailTemplateAttachment>> {
            const localVarFetchArgs = EmailTemplateAttachmentsApiFetchParamCreator(configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailTemplateAttachmentsApi - factory interface
 * @export
 */
export const EmailTemplateAttachmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List email template attachments
         * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplateAttachments(ids?: Array<number>, emailTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return EmailTemplateAttachmentsApiFp(configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * EmailTemplateAttachmentsApi - object-oriented interface
 * @export
 * @class EmailTemplateAttachmentsApi
 * @extends {BaseAPI}
 */
export class EmailTemplateAttachmentsApi extends BaseAPI {
    /**
     * Fetches multiple email template attachment records. The records can be filtered and paged according to the respective parameters. 
     * @summary List email template attachments
     * @param {Array<number>} [ids] IDs of email template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [emailTemplateId] Filters email template attachments by email template IDs
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateAttachmentsApi
     */
    public listEmailTemplateAttachments(ids?: Array<number>, emailTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return EmailTemplateAttachmentsApiFp(this.configuration).listEmailTemplateAttachments(ids, emailTemplateId, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * EmailTemplatesApi - fetch parameter creator
 * @export
 */
export const EmailTemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an email template, by ID only. 
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate(id: string, includeSignature?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnEmailTemplate.');
            }
            const localVarPath = `/v2/email_templates/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSignature !== undefined) {
                localVarQueryParameter['include_signature'] = includeSignature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates(ids?: Array<number>, updatedAt?: Array<string>, linkedToTeamTemplate?: boolean, search?: string, tagIds?: Array<number>, tag?: Array<string>, filterByOwner?: boolean, groupId?: Array<number>, includeCadenceTemplates?: boolean, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/email_templates.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (linkedToTeamTemplate !== undefined) {
                localVarQueryParameter['linked_to_team_template'] = linkedToTeamTemplate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            if (filterByOwner !== undefined) {
                localVarQueryParameter['filter_by_owner'] = filterByOwner;
            }

            if (groupId) {
                localVarQueryParameter['group_id'] = groupId.join(COLLECTION_FORMATS["csv"]);
            }

            if (includeCadenceTemplates !== undefined) {
                localVarQueryParameter['include_cadence_templates'] = includeCadenceTemplates;
            }

            if (includeArchivedTemplates !== undefined) {
                localVarQueryParameter['include_archived_templates'] = includeArchivedTemplates;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailTemplatesApi - functional programming interface
 * @export
 */
export const EmailTemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches an email template, by ID only. 
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate(id: string, includeSignature?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailTemplate> {
            const localVarFetchArgs = EmailTemplatesApiFetchParamCreator(configuration).fetchAnEmailTemplate(id, includeSignature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates(ids?: Array<number>, updatedAt?: Array<string>, linkedToTeamTemplate?: boolean, search?: string, tagIds?: Array<number>, tag?: Array<string>, filterByOwner?: boolean, groupId?: Array<number>, includeCadenceTemplates?: boolean, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EmailTemplate>> {
            const localVarFetchArgs = EmailTemplatesApiFetchParamCreator(configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailTemplatesApi - factory interface
 * @export
 */
export const EmailTemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches an email template, by ID only. 
         * @summary Fetch an email template
         * @param {string} id EmailTemplate ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmailTemplate(id: string, includeSignature?: boolean, options?: any) {
            return EmailTemplatesApiFp(configuration).fetchAnEmailTemplate(id, includeSignature, options)(fetch, basePath);
        },
        /**
         * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List email templates
         * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
         * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
         * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplates(ids?: Array<number>, updatedAt?: Array<string>, linkedToTeamTemplate?: boolean, search?: string, tagIds?: Array<number>, tag?: Array<string>, filterByOwner?: boolean, groupId?: Array<number>, includeCadenceTemplates?: boolean, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return EmailTemplatesApiFp(configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * EmailTemplatesApi - object-oriented interface
 * @export
 * @class EmailTemplatesApi
 * @extends {BaseAPI}
 */
export class EmailTemplatesApi extends BaseAPI {
    /**
     * Fetches an email template, by ID only. 
     * @summary Fetch an email template
     * @param {string} id EmailTemplate ID
     * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplatesApi
     */
    public fetchAnEmailTemplate(id: string, includeSignature?: boolean, options?: any) {
        return EmailTemplatesApiFp(this.configuration).fetchAnEmailTemplate(id, includeSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple email template records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List email templates
     * @param {Array<number>} [ids] IDs of email templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {boolean} [linkedToTeamTemplate] Filters email templates by whether they are linked to a team template or not
     * @param {string} [search] Filters email templates by title or subject
     * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
     * @param {Array<string>} [tag] Filters email templates by tags applied to the template, not to exceed 100 tags
     * @param {boolean} [filterByOwner] Filters email templates by current authenticated user
     * @param {Array<number>} [groupId] Filters email templates by groups applied to the template by group ID. Not to exceed 500 IDs. Returns templates that are assigned to any of the group ids.
     * @param {boolean} [includeCadenceTemplates] Filters email templates based on whether or not the template has been used on a cadence
     * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplatesApi
     */
    public listEmailTemplates(ids?: Array<number>, updatedAt?: Array<string>, linkedToTeamTemplate?: boolean, search?: string, tagIds?: Array<number>, tag?: Array<string>, filterByOwner?: boolean, groupId?: Array<number>, includeCadenceTemplates?: boolean, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return EmailTemplatesApiFp(this.configuration).listEmailTemplates(ids, updatedAt, linkedToTeamTemplate, search, tagIds, tag, filterByOwner, groupId, includeCadenceTemplates, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * EmailsApi - fetch parameter creator
 * @export
 */
export const EmailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an email, by ID only. 
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnEmail.');
            }
            const localVarPath = `/v2/activities/emails/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(ids?: Array<number>, updatedAt?: Array<string>, bounced?: boolean, crmActivityId?: Array<number>, actionId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/activities/emails.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (bounced !== undefined) {
                localVarQueryParameter['bounced'] = bounced;
            }

            if (crmActivityId) {
                localVarQueryParameter['crm_activity_id'] = crmActivityId.join(COLLECTION_FORMATS["csv"]);
            }

            if (actionId) {
                localVarQueryParameter['action_id'] = actionId.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailsApi - functional programming interface
 * @export
 */
export const EmailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches an email, by ID only. 
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailsApiFetchParamCreator(configuration).fetchAnEmail(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(ids?: Array<number>, updatedAt?: Array<string>, bounced?: boolean, crmActivityId?: Array<number>, actionId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Email>> {
            const localVarFetchArgs = EmailsApiFetchParamCreator(configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailsApi - factory interface
 * @export
 */
export const EmailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches an email, by ID only. 
         * @summary Fetch an email
         * @param {string} id Email ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnEmail(id: string, options?: any) {
            return EmailsApiFp(configuration).fetchAnEmail(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List emails
         * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {boolean} [bounced] Filters emails by whether they have bounced or not
         * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
         * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmails(ids?: Array<number>, updatedAt?: Array<string>, bounced?: boolean, crmActivityId?: Array<number>, actionId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return EmailsApiFp(configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * EmailsApi - object-oriented interface
 * @export
 * @class EmailsApi
 * @extends {BaseAPI}
 */
export class EmailsApi extends BaseAPI {
    /**
     * Fetches an email, by ID only. 
     * @summary Fetch an email
     * @param {string} id Email ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public fetchAnEmail(id: string, options?: any) {
        return EmailsApiFp(this.configuration).fetchAnEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple email records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List emails
     * @param {Array<number>} [ids] IDs of emails to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {boolean} [bounced] Filters emails by whether they have bounced or not
     * @param {Array<number>} [crmActivityId] Filters emails by crm_activity_id. Multiple crm activty ids can be applied
     * @param {Array<number>} [actionId] Filters emails by action_id. Multiple action ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailsApi
     */
    public listEmails(ids?: Array<number>, updatedAt?: Array<string>, bounced?: boolean, crmActivityId?: Array<number>, actionId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return EmailsApiFp(this.configuration).listEmails(ids, updatedAt, bounced, crmActivityId, actionId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * ImportsApi - fetch parameter creator
 * @export
 */
export const ImportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an import. 
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport(userId?: number, name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/imports.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (userId !== undefined) {
                localVarFormParams.set('user_id', userId as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport(id: string, undo?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAnImport.');
            }
            const localVarPath = `/v2/imports/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (undo !== undefined) {
                localVarQueryParameter['undo'] = undo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAnImport.');
            }
            const localVarPath = `/v2/imports/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple imports. 
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports(ids?: Array<number>, userIds?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/imports.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport(id: string, userId?: number, name?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAnImport.');
            }
            const localVarPath = `/v2/imports/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (userId !== undefined) {
                localVarFormParams.set('user_id', userId as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportsApi - functional programming interface
 * @export
 */
export const ImportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an import. 
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport(userId?: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelImport> {
            const localVarFetchArgs = ImportsApiFetchParamCreator(configuration).createAnImport(userId, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport(id: string, undo?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImportsApiFetchParamCreator(configuration).deleteAnImport(id, undo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelImport> {
            const localVarFetchArgs = ImportsApiFetchParamCreator(configuration).fetchAnImport(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple imports. 
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports(ids?: Array<number>, userIds?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelImport>> {
            const localVarFetchArgs = ImportsApiFetchParamCreator(configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport(id: string, userId?: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelImport> {
            const localVarFetchArgs = ImportsApiFetchParamCreator(configuration).updateAnImport(id, userId, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImportsApi - factory interface
 * @export
 */
export const ImportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an import. 
         * @summary Create an import
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnImport(userId?: number, name?: string, options?: any) {
            return ImportsApiFp(configuration).createAnImport(userId, name, options)(fetch, basePath);
        },
        /**
         * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Delete an import
         * @param {string} id Import ID
         * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnImport(id: string, undo?: string, options?: any) {
            return ImportsApiFp(configuration).deleteAnImport(id, undo, options)(fetch, basePath);
        },
        /**
         * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Fetch an import
         * @param {string} id Import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAnImport(id: string, options?: any) {
            return ImportsApiFp(configuration).fetchAnImport(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple imports. 
         * @summary List imports
         * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImports(ids?: Array<number>, userIds?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return ImportsApiFp(configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
         * @summary Update an import
         * @param {string} id Import ID
         * @param {number} [userId] ID of the User that owns this Import
         * @param {string} [name] Name, recommended to be easily identifiable to a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnImport(id: string, userId?: number, name?: string, options?: any) {
            return ImportsApiFp(configuration).updateAnImport(id, userId, name, options)(fetch, basePath);
        },
    };
};

/**
 * ImportsApi - object-oriented interface
 * @export
 * @class ImportsApi
 * @extends {BaseAPI}
 */
export class ImportsApi extends BaseAPI {
    /**
     * Creates an import. 
     * @summary Create an import
     * @param {number} [userId] ID of the User that owns this Import
     * @param {string} [name] Name, recommended to be easily identifiable to a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public createAnImport(userId?: number, name?: string, options?: any) {
        return ImportsApiFp(this.configuration).createAnImport(userId, name, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
     * @summary Delete an import
     * @param {string} id Import ID
     * @param {string} [undo] Whether to delete people on this Import. Possible values are: [not present], all, single.  &#39;single&#39; will delete people who are only present in this Import. &#39;all&#39; will delete people even if they are present in other Imports. Not specifying this parameter will not delete any people 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public deleteAnImport(id: string, undo?: string, options?: any) {
        return ImportsApiFp(this.configuration).deleteAnImport(id, undo, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
     * @summary Fetch an import
     * @param {string} id Import ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public fetchAnImport(id: string, options?: any) {
        return ImportsApiFp(this.configuration).fetchAnImport(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple imports. 
     * @summary List imports
     * @param {Array<number>} [ids] IDs of imports to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [userIds] ID of users to fetch imports for. Using this filter will return an empty array for non-admin users who request other user&#39;s imports
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to created_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public listImports(ids?: Array<number>, userIds?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return ImportsApiFp(this.configuration).listImports(ids, userIds, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an import, by ID only.  Admin users can access imports for the entire team, but non-admin users can only access their own imports. 
     * @summary Update an import
     * @param {string} id Import ID
     * @param {number} [userId] ID of the User that owns this Import
     * @param {string} [name] Name, recommended to be easily identifiable to a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public updateAnImport(id: string, userId?: number, name?: string, options?: any) {
        return ImportsApiFp(this.configuration).updateAnImport(id, userId, name, options)(this.fetch, this.basePath);
    }

}

/**
 * LiveWebsiteTrackingParametersApi - fetch parameter creator
 * @export
 */
export const LiveWebsiteTrackingParametersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person 
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter(personId: number, options: any = {}): FetchArgs {
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling createAnLiveWebsiteTrackingParameter.');
            }
            const localVarPath = `/v2/live_website_tracking_parameters.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (personId !== undefined) {
                localVarFormParams.set('person_id', personId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveWebsiteTrackingParametersApi - functional programming interface
 * @export
 */
export const LiveWebsiteTrackingParametersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person 
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter(personId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LiveWebsiteTrackingParameter> {
            const localVarFetchArgs = LiveWebsiteTrackingParametersApiFetchParamCreator(configuration).createAnLiveWebsiteTrackingParameter(personId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LiveWebsiteTrackingParametersApi - factory interface
 * @export
 */
export const LiveWebsiteTrackingParametersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a Live Website Tracking parameter to identify a person 
         * @summary Create an Live Website Tracking Parameter
         * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnLiveWebsiteTrackingParameter(personId: number, options?: any) {
            return LiveWebsiteTrackingParametersApiFp(configuration).createAnLiveWebsiteTrackingParameter(personId, options)(fetch, basePath);
        },
    };
};

/**
 * LiveWebsiteTrackingParametersApi - object-oriented interface
 * @export
 * @class LiveWebsiteTrackingParametersApi
 * @extends {BaseAPI}
 */
export class LiveWebsiteTrackingParametersApi extends BaseAPI {
    /**
     * Creates a Live Website Tracking parameter to identify a person 
     * @summary Create an Live Website Tracking Parameter
     * @param {number} personId The person to create the LiveWebsiteTrackingParameter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveWebsiteTrackingParametersApi
     */
    public createAnLiveWebsiteTrackingParameter(personId: number, options?: any) {
        return LiveWebsiteTrackingParametersApiFp(this.configuration).createAnLiveWebsiteTrackingParameter(personId, options)(this.fetch, this.basePath);
    }

}

/**
 * MeApi - fetch parameter creator
 * @export
 */
export const MeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team. 
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/v2/me.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team. 
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).fetchCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team. 
         * @summary Fetch current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentUser(options?: any) {
            return MeApiFp(configuration).fetchCurrentUser(options)(fetch, basePath);
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * Authenticated user information. This endpoint does not accept any parameters as it is represents your authenticated user. The \"Users\" resource provides user information for other users on the team. 
     * @summary Fetch current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public fetchCurrentUser(options?: any) {
        return MeApiFp(this.configuration).fetchCurrentUser(options)(this.fetch, this.basePath);
    }

}

/**
 * NotesApi - fetch parameter creator
 * @export
 */
export const NotesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a note. 
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote(content: string, associatedWithType: string, associatedWithId: number, skipCrmSync?: boolean, callId?: number, subject?: string, userGuid?: string, options: any = {}): FetchArgs {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling createANote.');
            }
            // verify required parameter 'associatedWithType' is not null or undefined
            if (associatedWithType === null || associatedWithType === undefined) {
                throw new RequiredError('associatedWithType','Required parameter associatedWithType was null or undefined when calling createANote.');
            }
            // verify required parameter 'associatedWithId' is not null or undefined
            if (associatedWithId === null || associatedWithId === undefined) {
                throw new RequiredError('associatedWithId','Required parameter associatedWithId was null or undefined when calling createANote.');
            }
            const localVarPath = `/v2/notes.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (content !== undefined) {
                localVarFormParams.set('content', content as any);
            }

            if (associatedWithType !== undefined) {
                localVarFormParams.set('associated_with_type', associatedWithType as any);
            }

            if (associatedWithId !== undefined) {
                localVarFormParams.set('associated_with_id', associatedWithId as any);
            }

            if (skipCrmSync !== undefined) {
                localVarFormParams.set('skip_crm_sync', skipCrmSync as any);
            }

            if (callId !== undefined) {
                localVarFormParams.set('call_id', callId as any);
            }

            if (subject !== undefined) {
                localVarFormParams.set('subject', subject as any);
            }

            if (userGuid !== undefined) {
                localVarFormParams.set('user_guid', userGuid as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteANote.');
            }
            const localVarPath = `/v2/notes/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a note, by ID only. 
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchANote.');
            }
            const localVarPath = `/v2/notes/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes(associatedWithType?: string, associatedWithId?: number, updatedAt?: Array<string>, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/notes.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (associatedWithType !== undefined) {
                localVarQueryParameter['associated_with_type'] = associatedWithType;
            }

            if (associatedWithId !== undefined) {
                localVarQueryParameter['associated_with_id'] = associatedWithId;
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com. 
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote(id: string, content: string, callId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateANote.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling updateANote.');
            }
            const localVarPath = `/v2/notes/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (content !== undefined) {
                localVarFormParams.set('content', content as any);
            }

            if (callId !== undefined) {
                localVarFormParams.set('call_id', callId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a note. 
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote(content: string, associatedWithType: string, associatedWithId: number, skipCrmSync?: boolean, callId?: number, subject?: string, userGuid?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Note> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).deleteANote(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a note, by ID only. 
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Note> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).fetchANote(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes(associatedWithType?: string, associatedWithId?: number, updatedAt?: Array<string>, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Note>> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com. 
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote(id: string, content: string, callId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Person> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).updateANote(id, content, callId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a note. 
         * @summary Create a note
         * @param {string} content The content of the note
         * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} associatedWithId ID of the item with which the note is associated
         * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
         * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
         * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANote(content: string, associatedWithType: string, associatedWithId: number, skipCrmSync?: boolean, callId?: number, subject?: string, userGuid?: string, options?: any) {
            return NotesApiFp(configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options)(fetch, basePath);
        },
        /**
         * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANote(id: string, options?: any) {
            return NotesApiFp(configuration).deleteANote(id, options)(fetch, basePath);
        },
        /**
         * Fetches a note, by ID only. 
         * @summary Fetch a note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchANote(id: string, options?: any) {
            return NotesApiFp(configuration).fetchANote(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List notes
         * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
         * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotes(associatedWithType?: string, associatedWithId?: number, updatedAt?: Array<string>, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return NotesApiFp(configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com. 
         * @summary Update a note
         * @param {string} id Note ID
         * @param {string} content The content of the note
         * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateANote(id: string, content: string, callId?: number, options?: any) {
            return NotesApiFp(configuration).updateANote(id, content, callId, options)(fetch, basePath);
        },
    };
};

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * Creates a note. 
     * @summary Create a note
     * @param {string} content The content of the note
     * @param {string} associatedWithType Case insensitive type of item with which the note is associated.  Value must be one of: person, account
     * @param {number} associatedWithId ID of the item with which the note is associated
     * @param {boolean} [skipCrmSync] Boolean indicating if the CRM sync should be skipped.  No syncing will occur if true
     * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note
     * @param {string} [subject] The subject of the note&#39;s crm activity, defaults to &#39;Note&#39;
     * @param {string} [userGuid] The user to create the note for. Only team admins may create notes on behalf of other users. Defaults to the requesting user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public createANote(content: string, associatedWithType: string, associatedWithId: number, skipCrmSync?: boolean, callId?: number, subject?: string, userGuid?: string, options?: any) {
        return NotesApiFp(this.configuration).createANote(content, associatedWithType, associatedWithId, skipCrmSync, callId, subject, userGuid, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a note owned by authorized account. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
     * @summary Delete a note
     * @param {string} id Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public deleteANote(id: string, options?: any) {
        return NotesApiFp(this.configuration).deleteANote(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a note, by ID only. 
     * @summary Fetch a note
     * @param {string} id Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public fetchANote(id: string, options?: any) {
        return NotesApiFp(this.configuration).fetchANote(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple note records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List notes
     * @param {string} [associatedWithType] Case insensitive type of item with which the note is associated.  Value must be one of: person, account
     * @param {number} [associatedWithId] ID of the item with which the note is associated.  The associated_with_type must also be present if this parameter is used
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {Array<number>} [ids] IDs of notes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public listNotes(associatedWithType?: string, associatedWithId?: number, updatedAt?: Array<string>, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return NotesApiFp(this.configuration).listNotes(associatedWithType, associatedWithId, updatedAt, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a note. Any changes to the note or associated records will not reflect in Salesforce.com. 
     * @summary Update a note
     * @param {string} id Note ID
     * @param {string} content The content of the note
     * @param {number} [callId] ID of the call with which the note is associated. The call cannot already have a note. If the note is associated to a call already, it will become associated to the requested call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public updateANote(id: string, content: string, callId?: number, options?: any) {
        return NotesApiFp(this.configuration).updateANote(id, content, callId, options)(this.fetch, this.basePath);
    }

}

/**
 * OngoingActionsApi - fetch parameter creator
 * @export
 */
export const OngoingActionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity. 
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction(actionId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/ongoing_actions.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (actionId !== undefined) {
                localVarFormParams.set('action_id', actionId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OngoingActionsApi - functional programming interface
 * @export
 */
export const OngoingActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity. 
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction(actionId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Action> {
            const localVarFetchArgs = OngoingActionsApiFetchParamCreator(configuration).createAnOngoingAction(actionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OngoingActionsApi - factory interface
 * @export
 */
export const OngoingActionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity. 
         * @summary Create an ongoing action
         * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnOngoingAction(actionId?: number, options?: any) {
            return OngoingActionsApiFp(configuration).createAnOngoingAction(actionId, options)(fetch, basePath);
        },
    };
};

/**
 * OngoingActionsApi - object-oriented interface
 * @export
 * @class OngoingActionsApi
 * @extends {BaseAPI}
 */
export class OngoingActionsApi extends BaseAPI {
    /**
     * Creates an ongoing action. An ongoing action is an action that is not yet completed, but progress has been made towards the completion. The user should not need to do anything for an ongoing action to be completed. An ongoing action can be later completed by creating an activity.  Ongoing actions are marked as status=pending_activity. 
     * @summary Create an ongoing action
     * @param {number} [actionId] Action that is being marked ongoing. This will validate that the action is still valid before modifying it. Ongoing actions can not be marked ongoing. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OngoingActionsApi
     */
    public createAnOngoingAction(actionId?: number, options?: any) {
        return OngoingActionsApiFp(this.configuration).createAnOngoingAction(actionId, options)(this.fetch, this.basePath);
    }

}

/**
 * PeopleApi - fetch parameter creator
 * @export
 */
export const PeopleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team. 
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson(emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, autotagDate?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/people.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (emailAddress !== undefined) {
                localVarFormParams.set('email_address', emailAddress as any);
            }

            if (secondaryEmailAddress !== undefined) {
                localVarFormParams.set('secondary_email_address', secondaryEmailAddress as any);
            }

            if (personalEmailAddress !== undefined) {
                localVarFormParams.set('personal_email_address', personalEmailAddress as any);
            }

            if (firstName !== undefined) {
                localVarFormParams.set('first_name', firstName as any);
            }

            if (lastName !== undefined) {
                localVarFormParams.set('last_name', lastName as any);
            }

            if (phone !== undefined) {
                localVarFormParams.set('phone', phone as any);
            }

            if (phoneExtension !== undefined) {
                localVarFormParams.set('phone_extension', phoneExtension as any);
            }

            if (mobilePhone !== undefined) {
                localVarFormParams.set('mobile_phone', mobilePhone as any);
            }

            if (homePhone !== undefined) {
                localVarFormParams.set('home_phone', homePhone as any);
            }

            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl as any);
            }

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (city !== undefined) {
                localVarFormParams.set('city', city as any);
            }

            if (state !== undefined) {
                localVarFormParams.set('state', state as any);
            }

            if (country !== undefined) {
                localVarFormParams.set('country', country as any);
            }

            if (workCity !== undefined) {
                localVarFormParams.set('work_city', workCity as any);
            }

            if (workState !== undefined) {
                localVarFormParams.set('work_state', workState as any);
            }

            if (workCountry !== undefined) {
                localVarFormParams.set('work_country', workCountry as any);
            }

            if (personCompanyName !== undefined) {
                localVarFormParams.set('person_company_name', personCompanyName as any);
            }

            if (personCompanyWebsite !== undefined) {
                localVarFormParams.set('person_company_website', personCompanyWebsite as any);
            }

            if (personCompanyIndustry !== undefined) {
                localVarFormParams.set('person_company_industry', personCompanyIndustry as any);
            }

            if (jobSeniority !== undefined) {
                localVarFormParams.set('job_seniority', jobSeniority as any);
            }

            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact as any);
            }

            if (locale !== undefined) {
                localVarFormParams.set('locale', locale as any);
            }

            if (personalWebsite !== undefined) {
                localVarFormParams.set('personal_website', personalWebsite as any);
            }

            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle as any);
            }

            if (tags) {
                    localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS["csv"]));
            }

            if (contactRestrictions) {
                    localVarFormParams.set('contact_restrictions', contactRestrictions.join(COLLECTION_FORMATS["csv"]));
            }

            if (customFields) {
                    localVarFormParams.set('custom_fields', customFields.join(COLLECTION_FORMATS["csv"]));
            }

            if (accountId !== undefined) {
                localVarFormParams.set('account_id', accountId as any);
            }

            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId as any);
            }

            if (importId !== undefined) {
                localVarFormParams.set('import_id', importId as any);
            }

            if (personStageId !== undefined) {
                localVarFormParams.set('person_stage_id', personStageId as any);
            }

            if (autotagDate !== undefined) {
                localVarFormParams.set('autotag_date', autotagDate as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAPerson.');
            }
            const localVarPath = `/v2/people/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a person, by ID only. 
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAPerson.');
            }
            const localVarPath = `/v2/people/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople(ids?: Array<number>, updatedAt?: Array<string>, emailAddresses?: Array<string>, ownedByGuid?: Array<string>, personStageId?: Array<number>, crmId?: Array<string>, doNotContact?: boolean, canEmail?: boolean, canCall?: boolean, accountId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/people.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (emailAddresses) {
                localVarQueryParameter['email_addresses'] = emailAddresses.join(COLLECTION_FORMATS["csv"]);
            }

            if (ownedByGuid) {
                localVarQueryParameter['owned_by_guid'] = ownedByGuid.join(COLLECTION_FORMATS["csv"]);
            }

            if (personStageId) {
                localVarQueryParameter['person_stage_id'] = personStageId.join(COLLECTION_FORMATS["csv"]);
            }

            if (crmId) {
                localVarQueryParameter['crm_id'] = crmId.join(COLLECTION_FORMATS["csv"]);
            }

            if (doNotContact !== undefined) {
                localVarQueryParameter['do_not_contact'] = doNotContact;
            }

            if (canEmail !== undefined) {
                localVarQueryParameter['can_email'] = canEmail;
            }

            if (canCall !== undefined) {
                localVarQueryParameter['can_call'] = canCall;
            }

            if (accountId) {
                localVarQueryParameter['account_id'] = accountId.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person. 
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson(id: string, emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAPerson.');
            }
            const localVarPath = `/v2/people/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (emailAddress !== undefined) {
                localVarFormParams.set('email_address', emailAddress as any);
            }

            if (secondaryEmailAddress !== undefined) {
                localVarFormParams.set('secondary_email_address', secondaryEmailAddress as any);
            }

            if (personalEmailAddress !== undefined) {
                localVarFormParams.set('personal_email_address', personalEmailAddress as any);
            }

            if (firstName !== undefined) {
                localVarFormParams.set('first_name', firstName as any);
            }

            if (lastName !== undefined) {
                localVarFormParams.set('last_name', lastName as any);
            }

            if (phone !== undefined) {
                localVarFormParams.set('phone', phone as any);
            }

            if (phoneExtension !== undefined) {
                localVarFormParams.set('phone_extension', phoneExtension as any);
            }

            if (mobilePhone !== undefined) {
                localVarFormParams.set('mobile_phone', mobilePhone as any);
            }

            if (homePhone !== undefined) {
                localVarFormParams.set('home_phone', homePhone as any);
            }

            if (linkedinUrl !== undefined) {
                localVarFormParams.set('linkedin_url', linkedinUrl as any);
            }

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (city !== undefined) {
                localVarFormParams.set('city', city as any);
            }

            if (state !== undefined) {
                localVarFormParams.set('state', state as any);
            }

            if (country !== undefined) {
                localVarFormParams.set('country', country as any);
            }

            if (workCity !== undefined) {
                localVarFormParams.set('work_city', workCity as any);
            }

            if (workState !== undefined) {
                localVarFormParams.set('work_state', workState as any);
            }

            if (workCountry !== undefined) {
                localVarFormParams.set('work_country', workCountry as any);
            }

            if (personCompanyName !== undefined) {
                localVarFormParams.set('person_company_name', personCompanyName as any);
            }

            if (personCompanyWebsite !== undefined) {
                localVarFormParams.set('person_company_website', personCompanyWebsite as any);
            }

            if (personCompanyIndustry !== undefined) {
                localVarFormParams.set('person_company_industry', personCompanyIndustry as any);
            }

            if (jobSeniority !== undefined) {
                localVarFormParams.set('job_seniority', jobSeniority as any);
            }

            if (doNotContact !== undefined) {
                localVarFormParams.set('do_not_contact', doNotContact as any);
            }

            if (locale !== undefined) {
                localVarFormParams.set('locale', locale as any);
            }

            if (personalWebsite !== undefined) {
                localVarFormParams.set('personal_website', personalWebsite as any);
            }

            if (twitterHandle !== undefined) {
                localVarFormParams.set('twitter_handle', twitterHandle as any);
            }

            if (tags) {
                    localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS["csv"]));
            }

            if (contactRestrictions) {
                    localVarFormParams.set('contact_restrictions', contactRestrictions.join(COLLECTION_FORMATS["csv"]));
            }

            if (customFields) {
                    localVarFormParams.set('custom_fields', customFields.join(COLLECTION_FORMATS["csv"]));
            }

            if (accountId !== undefined) {
                localVarFormParams.set('account_id', accountId as any);
            }

            if (ownerId !== undefined) {
                localVarFormParams.set('owner_id', ownerId as any);
            }

            if (importId !== undefined) {
                localVarFormParams.set('import_id', importId as any);
            }

            if (personStageId !== undefined) {
                localVarFormParams.set('person_stage_id', personStageId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 * @export
 */
export const PeopleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team. 
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson(emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, autotagDate?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Person> {
            const localVarFetchArgs = PeopleApiFetchParamCreator(configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeopleApiFetchParamCreator(configuration).deleteAPerson(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a person, by ID only. 
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Person> {
            const localVarFetchArgs = PeopleApiFetchParamCreator(configuration).fetchAPerson(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople(ids?: Array<number>, updatedAt?: Array<string>, emailAddresses?: Array<string>, ownedByGuid?: Array<string>, personStageId?: Array<number>, crmId?: Array<string>, doNotContact?: boolean, canEmail?: boolean, canCall?: boolean, accountId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Person>> {
            const localVarFetchArgs = PeopleApiFetchParamCreator(configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a person. 
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson(id: string, emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Person> {
            const localVarFetchArgs = PeopleApiFetchParamCreator(configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PeopleApi - factory interface
 * @export
 */
export const PeopleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team. 
         * @summary Create a person
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPerson(emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, autotagDate?: boolean, options?: any) {
            return PeopleApiFp(configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options)(fetch, basePath);
        },
        /**
         * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a person
         * @param {string} id Person id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPerson(id: string, options?: any) {
            return PeopleApiFp(configuration).deleteAPerson(id, options)(fetch, basePath);
        },
        /**
         * Fetches a person, by ID only. 
         * @summary Fetch a person
         * @param {string} id Person ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPerson(id: string, options?: any) {
            return PeopleApiFp(configuration).fetchAPerson(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List people
         * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
         * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
         * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
         * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
         * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
         * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
         * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
         * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeople(ids?: Array<number>, updatedAt?: Array<string>, emailAddresses?: Array<string>, ownedByGuid?: Array<string>, personStageId?: Array<number>, crmId?: Array<string>, doNotContact?: boolean, canEmail?: boolean, canCall?: boolean, accountId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return PeopleApiFp(configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a person. 
         * @summary Update a person
         * @param {string} id Person id
         * @param {string} [emailAddress] Email address
         * @param {string} [secondaryEmailAddress] Alternate email address
         * @param {string} [personalEmailAddress] Personal email address
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [phone] Phone without formatting
         * @param {string} [phoneExtension] Phone extension without formatting
         * @param {string} [mobilePhone] Mobile phone without formatting
         * @param {string} [homePhone] Home phone without formatting
         * @param {string} [linkedinUrl] Linkedin URL
         * @param {string} [title] Job title
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [country] Country
         * @param {string} [workCity] Work location - city
         * @param {string} [workState] Work location - state
         * @param {string} [workCountry] Work location - country
         * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
         * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
         * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
         * @param {string} [locale] Time locale of the person
         * @param {string} [personalWebsite] The website of this person
         * @param {string} [twitterHandle] The twitter handle of this person
         * @param {Array<string>} [tags] All tags applied to this person
         * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
         * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
         * @param {number} [accountId] ID of the Account to link this person to
         * @param {number} [ownerId] ID of the User that owns this person
         * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
         * @param {number} [personStageId] ID of the PersonStage of this person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPerson(id: string, emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, options?: any) {
            return PeopleApiFp(configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options)(fetch, basePath);
        },
    };
};

/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
export class PeopleApi extends BaseAPI {
    /**
     * Creates a person. Either email_address or phone/last_name must be provided as a unique lookup on the team. 
     * @summary Create a person
     * @param {string} [emailAddress] Email address
     * @param {string} [secondaryEmailAddress] Alternate email address
     * @param {string} [personalEmailAddress] Personal email address
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [phone] Phone without formatting
     * @param {string} [phoneExtension] Phone extension without formatting
     * @param {string} [mobilePhone] Mobile phone without formatting
     * @param {string} [homePhone] Home phone without formatting
     * @param {string} [linkedinUrl] Linkedin URL
     * @param {string} [title] Job title
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [country] Country
     * @param {string} [workCity] Work location - city
     * @param {string} [workState] Work location - state
     * @param {string} [workCountry] Work location - country
     * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
     * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
     * @param {string} [locale] Time locale of the person
     * @param {string} [personalWebsite] The website of this person
     * @param {string} [twitterHandle] The twitter handle of this person
     * @param {Array<string>} [tags] All tags applied to this person
     * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {number} [accountId] ID of the Account to link this person to
     * @param {number} [ownerId] ID of the User that owns this person
     * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
     * @param {number} [personStageId] ID of the PersonStage of this person
     * @param {boolean} [autotagDate] Whether the date should be added to this person as a tag. Default is false. The tag will be Y-m-d format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public createAPerson(emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, autotagDate?: boolean, options?: any) {
        return PeopleApiFp(this.configuration).createAPerson(emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, autotagDate, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a person. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
     * @summary Delete a person
     * @param {string} id Person id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public deleteAPerson(id: string, options?: any) {
        return PeopleApiFp(this.configuration).deleteAPerson(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a person, by ID only. 
     * @summary Fetch a person
     * @param {string} id Person ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public fetchAPerson(id: string, options?: any) {
        return PeopleApiFp(this.configuration).fetchAPerson(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple person records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List people
     * @param {Array<number>} [ids] IDs of people to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {Array<string>} [emailAddresses] Filters people by email address. Multiple emails can be applied
     * @param {Array<string>} [ownedByGuid] Filters people by the owner&#39;s guid. Multiple owner guids can be applied
     * @param {Array<number>} [personStageId] Includes people that have a given person_stage. Multiple person stage ids can be applied
     * @param {Array<string>} [crmId] Filters people by crm_id. Multiple crm ids can be applied
     * @param {boolean} [doNotContact] Includes people that have a given do_not_contact property
     * @param {boolean} [canEmail] Includes people that can be emailed given do_not_contact and contact_restrictions property
     * @param {boolean} [canCall] Includes people that can be called given do_not_contact and contact_restrictions property
     * @param {Array<number>} [accountId] Filters people by the account they are linked to. Multiple account ids can be applied
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_contacted_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public listPeople(ids?: Array<number>, updatedAt?: Array<string>, emailAddresses?: Array<string>, ownedByGuid?: Array<string>, personStageId?: Array<number>, crmId?: Array<string>, doNotContact?: boolean, canEmail?: boolean, canCall?: boolean, accountId?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return PeopleApiFp(this.configuration).listPeople(ids, updatedAt, emailAddresses, ownedByGuid, personStageId, crmId, doNotContact, canEmail, canCall, accountId, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a person. 
     * @summary Update a person
     * @param {string} id Person id
     * @param {string} [emailAddress] Email address
     * @param {string} [secondaryEmailAddress] Alternate email address
     * @param {string} [personalEmailAddress] Personal email address
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [phone] Phone without formatting
     * @param {string} [phoneExtension] Phone extension without formatting
     * @param {string} [mobilePhone] Mobile phone without formatting
     * @param {string} [homePhone] Home phone without formatting
     * @param {string} [linkedinUrl] Linkedin URL
     * @param {string} [title] Job title
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [country] Country
     * @param {string} [workCity] Work location - city
     * @param {string} [workState] Work location - state
     * @param {string} [workCountry] Work location - country
     * @param {string} [personCompanyName] Company name. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyWebsite] Company website. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [personCompanyIndustry] Company industry. This property is specific to this person, unrelated to the company object. Updating the company object associated with this person is recommended
     * @param {string} [jobSeniority] The Job Seniority of a Person, must be one of director, executive, individual_contributor, manager, vice_president, unknown
     * @param {boolean} [doNotContact] Whether or not this person has opted out of all communication. Setting this value to true prevents this person from being called, emailed, or added to a cadence in SalesLoft. If this person is currently in a cadence, they will be removed.
     * @param {string} [locale] Time locale of the person
     * @param {string} [personalWebsite] The website of this person
     * @param {string} [twitterHandle] The twitter handle of this person
     * @param {Array<string>} [tags] All tags applied to this person
     * @param {Array<string>} [contactRestrictions] Specific methods of communication to prevent for this person. This will prevent individual execution of these communication types as well as automatically skip cadence steps of this communication type for this person in SalesLoft. Values currently accepted: call, email, message
     * @param {Array<string>} [customFields] Custom fields are defined by the user&#39;s team. Only fields with values are presented in the API.
     * @param {number} [accountId] ID of the Account to link this person to
     * @param {number} [ownerId] ID of the User that owns this person
     * @param {number} [importId] ID of the Import this person is a part of. A person can be part of multiple imports, but this ID will always be the most recent Import
     * @param {number} [personStageId] ID of the PersonStage of this person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public updateAPerson(id: string, emailAddress?: string, secondaryEmailAddress?: string, personalEmailAddress?: string, firstName?: string, lastName?: string, phone?: string, phoneExtension?: string, mobilePhone?: string, homePhone?: string, linkedinUrl?: string, title?: string, city?: string, state?: string, country?: string, workCity?: string, workState?: string, workCountry?: string, personCompanyName?: string, personCompanyWebsite?: string, personCompanyIndustry?: string, jobSeniority?: string, doNotContact?: boolean, locale?: string, personalWebsite?: string, twitterHandle?: string, tags?: Array<string>, contactRestrictions?: Array<string>, customFields?: Array<string>, accountId?: number, ownerId?: number, importId?: number, personStageId?: number, options?: any) {
        return PeopleApiFp(this.configuration).updateAPerson(id, emailAddress, secondaryEmailAddress, personalEmailAddress, firstName, lastName, phone, phoneExtension, mobilePhone, homePhone, linkedinUrl, title, city, state, country, workCity, workState, workCountry, personCompanyName, personCompanyWebsite, personCompanyIndustry, jobSeniority, doNotContact, locale, personalWebsite, twitterHandle, tags, contactRestrictions, customFields, accountId, ownerId, importId, personStageId, options)(this.fetch, this.basePath);
    }

}

/**
 * PersonStagesApi - fetch parameter creator
 * @export
 */
export const PersonStagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a person stage. 
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createAPersonStage.');
            }
            const localVarPath = `/v2/person_stages.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAnPersonStage.');
            }
            const localVarPath = `/v2/person_stages/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a person stage, by ID only. 
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAPersonStage.');
            }
            const localVarPath = `/v2/person_stages/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/person_stages.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person stage. 
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAPersonStage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateAPersonStage.');
            }
            const localVarPath = `/v2/person_stages/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonStagesApi - functional programming interface
 * @export
 */
export const PersonStagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a person stage. 
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersonStage> {
            const localVarFetchArgs = PersonStagesApiFetchParamCreator(configuration).createAPersonStage(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersonStagesApiFetchParamCreator(configuration).deleteAnPersonStage(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a person stage, by ID only. 
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersonStage> {
            const localVarFetchArgs = PersonStagesApiFetchParamCreator(configuration).fetchAPersonStage(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PersonStage>> {
            const localVarFetchArgs = PersonStagesApiFetchParamCreator(configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a person stage. 
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersonStage> {
            const localVarFetchArgs = PersonStagesApiFetchParamCreator(configuration).updateAPersonStage(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PersonStagesApi - factory interface
 * @export
 */
export const PersonStagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a person stage. 
         * @summary Create a person stage
         * @param {string} name The name of the new stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPersonStage(name: string, options?: any) {
            return PersonStagesApiFp(configuration).createAPersonStage(name, options)(fetch, basePath);
        },
        /**
         * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete an person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnPersonStage(id: string, options?: any) {
            return PersonStagesApiFp(configuration).deleteAnPersonStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches a person stage, by ID only. 
         * @summary Fetch a person stage
         * @param {string} id Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPersonStage(id: string, options?: any) {
            return PersonStagesApiFp(configuration).fetchAPersonStage(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List person stages
         * @param {Array<number>} [ids] IDs of person stages to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonStages(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return PersonStagesApiFp(configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a person stage. 
         * @summary Update a person stage
         * @param {string} id Stage ID
         * @param {string} name The name of the stage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPersonStage(id: string, name: string, options?: any) {
            return PersonStagesApiFp(configuration).updateAPersonStage(id, name, options)(fetch, basePath);
        },
    };
};

/**
 * PersonStagesApi - object-oriented interface
 * @export
 * @class PersonStagesApi
 * @extends {BaseAPI}
 */
export class PersonStagesApi extends BaseAPI {
    /**
     * Creates a person stage. 
     * @summary Create a person stage
     * @param {string} name The name of the new stage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    public createAPersonStage(name: string, options?: any) {
        return PersonStagesApiFp(this.configuration).createAPersonStage(name, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a person stage. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
     * @summary Delete an person stage
     * @param {string} id Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    public deleteAnPersonStage(id: string, options?: any) {
        return PersonStagesApiFp(this.configuration).deleteAnPersonStage(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a person stage, by ID only. 
     * @summary Fetch a person stage
     * @param {string} id Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    public fetchAPersonStage(id: string, options?: any) {
        return PersonStagesApiFp(this.configuration).fetchAPersonStage(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple person stage records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List person stages
     * @param {Array<number>} [ids] IDs of person stages to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    public listPersonStages(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return PersonStagesApiFp(this.configuration).listPersonStages(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a person stage. 
     * @summary Update a person stage
     * @param {string} id Stage ID
     * @param {string} name The name of the stage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonStagesApi
     */
    public updateAPersonStage(id: string, name: string, options?: any) {
        return PersonStagesApiFp(this.configuration).updateAPersonStage(id, name, options)(this.fetch, this.basePath);
    }

}

/**
 * PhoneNumberAssignmentsApi - fetch parameter creator
 * @export
 */
export const PhoneNumberAssignmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a phone number assignment, by ID only. 
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAPhoneNumberAssignment.');
            }
            const localVarPath = `/v2/phone_number_assignments/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/phone_number_assignments.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneNumberAssignmentsApi - functional programming interface
 * @export
 */
export const PhoneNumberAssignmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a phone number assignment, by ID only. 
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PhoneNumberAssignment> {
            const localVarFetchArgs = PhoneNumberAssignmentsApiFetchParamCreator(configuration).fetchAPhoneNumberAssignment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PhoneNumberAssignment>> {
            const localVarFetchArgs = PhoneNumberAssignmentsApiFetchParamCreator(configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PhoneNumberAssignmentsApi - factory interface
 * @export
 */
export const PhoneNumberAssignmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a phone number assignment, by ID only. 
         * @summary Fetch a phone number assignment
         * @param {string} id PhoneNumberAssignment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAPhoneNumberAssignment(id: string, options?: any) {
            return PhoneNumberAssignmentsApiFp(configuration).fetchAPhoneNumberAssignment(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List phone number assignments
         * @param {Array<number>} [ids] IDs of phone number assignments to fetch
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneNumberAssignments(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return PhoneNumberAssignmentsApiFp(configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * PhoneNumberAssignmentsApi - object-oriented interface
 * @export
 * @class PhoneNumberAssignmentsApi
 * @extends {BaseAPI}
 */
export class PhoneNumberAssignmentsApi extends BaseAPI {
    /**
     * Fetches a phone number assignment, by ID only. 
     * @summary Fetch a phone number assignment
     * @param {string} id PhoneNumberAssignment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneNumberAssignmentsApi
     */
    public fetchAPhoneNumberAssignment(id: string, options?: any) {
        return PhoneNumberAssignmentsApiFp(this.configuration).fetchAPhoneNumberAssignment(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List phone number assignments
     * @param {Array<number>} [ids] IDs of phone number assignments to fetch
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneNumberAssignmentsApi
     */
    public listPhoneNumberAssignments(ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return PhoneNumberAssignmentsApiFp(this.configuration).listPhoneNumberAssignments(ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * RecordingSettingsApi - fetch parameter creator
 * @export
 */
export const RecordingSettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format. 
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchRecordingSetting.');
            }
            const localVarPath = `/v2/phone_numbers/recording_settings/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordingSettingsApi - functional programming interface
 * @export
 */
export const RecordingSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format. 
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecordingSetting> {
            const localVarFetchArgs = RecordingSettingsApiFetchParamCreator(configuration).fetchRecordingSetting(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecordingSettingsApi - factory interface
 * @export
 */
export const RecordingSettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format. 
         * @summary Fetch recording setting
         * @param {string} id E.164 Phone Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRecordingSetting(id: string, options?: any) {
            return RecordingSettingsApiFp(configuration).fetchRecordingSetting(id, options)(fetch, basePath);
        },
    };
};

/**
 * RecordingSettingsApi - object-oriented interface
 * @export
 * @class RecordingSettingsApi
 * @extends {BaseAPI}
 */
export class RecordingSettingsApi extends BaseAPI {
    /**
     * Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team. Phone number should be in E.164 format. 
     * @summary Fetch recording setting
     * @param {string} id E.164 Phone Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingSettingsApi
     */
    public fetchRecordingSetting(id: string, options?: any) {
        return RecordingSettingsApiFp(this.configuration).fetchRecordingSetting(id, options)(this.fetch, this.basePath);
    }

}

/**
 * SavedListViewsApi - fetch parameter creator
 * @export
 */
export const SavedListViewsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a saved list view. 
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView(name: string, view: string, isDefault?: boolean, viewParams?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createASavedListView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling createASavedListView.');
            }
            const localVarPath = `/v2/saved_list_views.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (view !== undefined) {
                localVarFormParams.set('view', view as any);
            }

            if (isDefault !== undefined) {
                localVarFormParams.set('is_default', isDefault as any);
            }

            if (viewParams !== undefined) {
                localVarFormParams.set('view_params', viewParams as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteASavedListView.');
            }
            const localVarPath = `/v2/saved_list_views/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a saved list view, by ID only. 
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchASavedListView.');
            }
            const localVarPath = `/v2/saved_list_views/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews(ids?: Array<number>, view?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/saved_list_views.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a saved list view. 
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView(id: string, name?: string, isDefault?: boolean, viewParams?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateASavedListView.');
            }
            const localVarPath = `/v2/saved_list_views/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (isDefault !== undefined) {
                localVarFormParams.set('is_default', isDefault as any);
            }

            if (viewParams !== undefined) {
                localVarFormParams.set('view_params', viewParams as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedListViewsApi - functional programming interface
 * @export
 */
export const SavedListViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a saved list view. 
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView(name: string, view: string, isDefault?: boolean, viewParams?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SavedListView> {
            const localVarFetchArgs = SavedListViewsApiFetchParamCreator(configuration).createASavedListView(name, view, isDefault, viewParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SavedListViewsApiFetchParamCreator(configuration).deleteASavedListView(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a saved list view, by ID only. 
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SavedListView> {
            const localVarFetchArgs = SavedListViewsApiFetchParamCreator(configuration).fetchASavedListView(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews(ids?: Array<number>, view?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SavedListView>> {
            const localVarFetchArgs = SavedListViewsApiFetchParamCreator(configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a saved list view. 
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView(id: string, name?: string, isDefault?: boolean, viewParams?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SavedListView> {
            const localVarFetchArgs = SavedListViewsApiFetchParamCreator(configuration).updateASavedListView(id, name, isDefault, viewParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SavedListViewsApi - factory interface
 * @export
 */
export const SavedListViewsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a saved list view. 
         * @summary Create a saved list view
         * @param {string} name The name of the saved list view
         * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASavedListView(name: string, view: string, isDefault?: boolean, viewParams?: string, options?: any) {
            return SavedListViewsApiFp(configuration).createASavedListView(name, view, isDefault, viewParams, options)(fetch, basePath);
        },
        /**
         * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
         * @summary Delete a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASavedListView(id: string, options?: any) {
            return SavedListViewsApiFp(configuration).deleteASavedListView(id, options)(fetch, basePath);
        },
        /**
         * Fetches a saved list view, by ID only. 
         * @summary Fetch a saved list view
         * @param {string} id Saved List View ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchASavedListView(id: string, options?: any) {
            return SavedListViewsApiFp(configuration).fetchASavedListView(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List saved list views
         * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {string} [view] Type of saved list views to fetch.
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedListViews(ids?: Array<number>, view?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return SavedListViewsApiFp(configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
        /**
         * Updates a saved list view. 
         * @summary Update a saved list view
         * @param {string} id Saved List View ID
         * @param {string} [name] The name of the saved list view
         * @param {boolean} [isDefault] Whether the saved list view is the default
         * @param {string} [viewParams] JSON object of list view parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateASavedListView(id: string, name?: string, isDefault?: boolean, viewParams?: string, options?: any) {
            return SavedListViewsApiFp(configuration).updateASavedListView(id, name, isDefault, viewParams, options)(fetch, basePath);
        },
    };
};

/**
 * SavedListViewsApi - object-oriented interface
 * @export
 * @class SavedListViewsApi
 * @extends {BaseAPI}
 */
export class SavedListViewsApi extends BaseAPI {
    /**
     * Creates a saved list view. 
     * @summary Create a saved list view
     * @param {string} name The name of the saved list view
     * @param {string} view The type of objects in the saved list view.  Value must be one of: people, companies
     * @param {boolean} [isDefault] Whether the saved list view is the default
     * @param {string} [viewParams] JSON object of list view parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    public createASavedListView(name: string, view: string, isDefault?: boolean, viewParams?: string, options?: any) {
        return SavedListViewsApiFp(this.configuration).createASavedListView(name, view, isDefault, viewParams, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a saved list view. This operation is not reversible without contacting support. This operation can be called multiple times successfully. 
     * @summary Delete a saved list view
     * @param {string} id Saved List View ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    public deleteASavedListView(id: string, options?: any) {
        return SavedListViewsApiFp(this.configuration).deleteASavedListView(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a saved list view, by ID only. 
     * @summary Fetch a saved list view
     * @param {string} id Saved List View ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    public fetchASavedListView(id: string, options?: any) {
        return SavedListViewsApiFp(this.configuration).fetchASavedListView(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List saved list views
     * @param {Array<number>} [ids] IDs of saved list views to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {string} [view] Type of saved list views to fetch.
     * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    public listSavedListViews(ids?: Array<number>, view?: string, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return SavedListViewsApiFp(this.configuration).listSavedListViews(ids, view, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a saved list view. 
     * @summary Update a saved list view
     * @param {string} id Saved List View ID
     * @param {string} [name] The name of the saved list view
     * @param {boolean} [isDefault] Whether the saved list view is the default
     * @param {string} [viewParams] JSON object of list view parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedListViewsApi
     */
    public updateASavedListView(id: string, name?: string, isDefault?: boolean, viewParams?: string, options?: any) {
        return SavedListViewsApiFp(this.configuration).updateASavedListView(id, name, isDefault, viewParams, options)(this.fetch, this.basePath);
    }

}

/**
 * StepsApi - fetch parameter creator
 * @export
 */
export const StepsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a step, by ID only. 
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAStep.');
            }
            const localVarPath = `/v2/steps/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(ids?: Array<number>, cadenceId?: number, type?: string, hasDueActions?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/steps.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (cadenceId !== undefined) {
                localVarQueryParameter['cadence_id'] = cadenceId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (hasDueActions !== undefined) {
                localVarQueryParameter['has_due_actions'] = hasDueActions;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StepsApi - functional programming interface
 * @export
 */
export const StepsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a step, by ID only. 
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Step> {
            const localVarFetchArgs = StepsApiFetchParamCreator(configuration).fetchAStep(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(ids?: Array<number>, cadenceId?: number, type?: string, hasDueActions?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Step>> {
            const localVarFetchArgs = StepsApiFetchParamCreator(configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StepsApi - factory interface
 * @export
 */
export const StepsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a step, by ID only. 
         * @summary Fetch a step
         * @param {string} id Step ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAStep(id: string, options?: any) {
            return StepsApiFp(configuration).fetchAStep(id, options)(fetch, basePath);
        },
        /**
         * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List steps
         * @param {Array<number>} [ids] IDs of steps to fetch.
         * @param {number} [cadenceId] Filter by cadence ID
         * @param {string} [type] Filter by step type
         * @param {boolean} [hasDueActions] Filter by whether a step has due actions
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(ids?: Array<number>, cadenceId?: number, type?: string, hasDueActions?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return StepsApiFp(configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * StepsApi - object-oriented interface
 * @export
 * @class StepsApi
 * @extends {BaseAPI}
 */
export class StepsApi extends BaseAPI {
    /**
     * Fetches a step, by ID only. 
     * @summary Fetch a step
     * @param {string} id Step ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApi
     */
    public fetchAStep(id: string, options?: any) {
        return StepsApiFp(this.configuration).fetchAStep(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple step records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List steps
     * @param {Array<number>} [ids] IDs of steps to fetch.
     * @param {number} [cadenceId] Filter by cadence ID
     * @param {string} [type] Filter by step type
     * @param {boolean} [hasDueActions] Filter by whether a step has due actions
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApi
     */
    public listSteps(ids?: Array<number>, cadenceId?: number, type?: string, hasDueActions?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return StepsApiFp(this.configuration).listSteps(ids, cadenceId, type, hasDueActions, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * SuccessesApi - fetch parameter creator
 * @export
 */
export const SuccessesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses(ids?: Array<number>, personId?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/successes.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (personId) {
                localVarQueryParameter['person_id'] = personId.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuccessesApi - functional programming interface
 * @export
 */
export const SuccessesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses(ids?: Array<number>, personId?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Success>> {
            const localVarFetchArgs = SuccessesApiFetchParamCreator(configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SuccessesApi - factory interface
 * @export
 */
export const SuccessesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters. 
         * @summary List successes
         * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuccesses(ids?: Array<number>, personId?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return SuccessesApiFp(configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * SuccessesApi - object-oriented interface
 * @export
 * @class SuccessesApi
 * @extends {BaseAPI}
 */
export class SuccessesApi extends BaseAPI {
    /**
     * Fetches multiple success records. The records can be filtered, paged, and sorted according to the respective parameters. 
     * @summary List successes
     * @param {Array<number>} [ids] IDs of successes to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [personId] Filters successes by person_id. Multiple person ids can be applied
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, succeeded_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuccessesApi
     */
    public listSuccesses(ids?: Array<number>, personId?: Array<number>, updatedAt?: Array<string>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return SuccessesApiFp(this.configuration).listSuccesses(ids, personId, updatedAt, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types. 
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags(search?: string, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/tags.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types. 
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags(search?: string, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types. 
         * @summary List team tags
         * @param {string} [search] Filters tags by name
         * @param {Array<number>} [ids] Filters tags by their IDs
         * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTags(search?: string, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return TagsApiFp(configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to the respective parameters.  Tags can be applied to mulitple resource types. 
     * @summary List team tags
     * @param {string} [search] Filters tags by name
     * @param {Array<number>} [ids] Filters tags by their IDs
     * @param {string} [sortBy] Key to sort on, must be one of: name. Defaults to name
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTeamTags(search?: string, ids?: Array<number>, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return TagsApiFp(this.configuration).listTeamTags(search, ids, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamApi - fetch parameter creator
 * @export
 */
export const TeamApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the team of the authenticated user. 
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam(options: any = {}): FetchArgs {
            const localVarPath = `/v2/team.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches the team of the authenticated user. 
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).fetchCurrentTeam(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches the team of the authenticated user. 
         * @summary Fetch current team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCurrentTeam(options?: any) {
            return TeamApiFp(configuration).fetchCurrentTeam(options)(fetch, basePath);
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Fetches the team of the authenticated user. 
     * @summary Fetch current team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public fetchCurrentTeam(options?: any) {
        return TeamApiFp(this.configuration).fetchCurrentTeam(options)(this.fetch, this.basePath);
    }

}

/**
 * TeamTemplateAttachmentsApi - fetch parameter creator
 * @export
 */
export const TeamTemplateAttachmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments(ids?: Array<number>, teamTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/team_template_attachments.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (teamTemplateId) {
                localVarQueryParameter['team_template_id'] = teamTemplateId.join(COLLECTION_FORMATS["csv"]);
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamTemplateAttachmentsApi - functional programming interface
 * @export
 */
export const TeamTemplateAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments(ids?: Array<number>, teamTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamTemplateAttachment>> {
            const localVarFetchArgs = TeamTemplateAttachmentsApiFetchParamCreator(configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamTemplateAttachmentsApi - factory interface
 * @export
 */
export const TeamTemplateAttachmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters. 
         * @summary List team template attachments
         * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplateAttachments(ids?: Array<number>, teamTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return TeamTemplateAttachmentsApiFp(configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * TeamTemplateAttachmentsApi - object-oriented interface
 * @export
 * @class TeamTemplateAttachmentsApi
 * @extends {BaseAPI}
 */
export class TeamTemplateAttachmentsApi extends BaseAPI {
    /**
     * Fetches multiple team template attachment records. The records can be filtered and paged according to the respective parameters. 
     * @summary List team template attachments
     * @param {Array<number>} [ids] IDs of team template attachments to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<number>} [teamTemplateId] Filters template attachments by team template IDs
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplateAttachmentsApi
     */
    public listTeamTemplateAttachments(ids?: Array<number>, teamTemplateId?: Array<number>, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return TeamTemplateAttachmentsApiFp(this.configuration).listTeamTemplateAttachments(ids, teamTemplateId, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamTemplatesApi - fetch parameter creator
 * @export
 */
export const TeamTemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a team template, by ID only. 
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate(id: string, includeSignature?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchATeamTemplate.');
            }
            const localVarPath = `/v2/team_templates/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSignature !== undefined) {
                localVarQueryParameter['include_signature'] = includeSignature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint. 
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates(ids?: Array<string>, updatedAt?: Array<string>, search?: string, tagIds?: Array<number>, tag?: Array<string>, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v2/team_templates.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS["csv"]);
            }

            if (updatedAt) {
                localVarQueryParameter['updated_at'] = updatedAt.join(COLLECTION_FORMATS["csv"]);
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            if (includeArchivedTemplates !== undefined) {
                localVarQueryParameter['include_archived_templates'] = includeArchivedTemplates;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePagingCounts !== undefined) {
                localVarQueryParameter['include_paging_counts'] = includePagingCounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamTemplatesApi - functional programming interface
 * @export
 */
export const TeamTemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a team template, by ID only. 
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate(id: string, includeSignature?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamTemplate> {
            const localVarFetchArgs = TeamTemplatesApiFetchParamCreator(configuration).fetchATeamTemplate(id, includeSignature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint. 
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates(ids?: Array<string>, updatedAt?: Array<string>, search?: string, tagIds?: Array<number>, tag?: Array<string>, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamTemplate>> {
            const localVarFetchArgs = TeamTemplatesApiFetchParamCreator(configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamTemplatesApi - factory interface
 * @export
 */
export const TeamTemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a team template, by ID only. 
         * @summary Fetch a team template
         * @param {string} id Team Template ID
         * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchATeamTemplate(id: string, includeSignature?: boolean, options?: any) {
            return TeamTemplatesApiFp(configuration).fetchATeamTemplate(id, includeSignature, options)(fetch, basePath);
        },
        /**
         * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint. 
         * @summary List team templates
         * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
         * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
         * @param {string} [search] Filters email templates by title or subject
         * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
         * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
         * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
         * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
         * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
         * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
         * @param {number} [page] The current page to fetch results from. Defaults to 1
         * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamTemplates(ids?: Array<string>, updatedAt?: Array<string>, search?: string, tagIds?: Array<number>, tag?: Array<string>, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
            return TeamTemplatesApiFp(configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(fetch, basePath);
        },
    };
};

/**
 * TeamTemplatesApi - object-oriented interface
 * @export
 * @class TeamTemplatesApi
 * @extends {BaseAPI}
 */
export class TeamTemplatesApi extends BaseAPI {
    /**
     * Fetches a team template, by ID only. 
     * @summary Fetch a team template
     * @param {string} id Team Template ID
     * @param {boolean} [includeSignature] Optionally will return the templates with the current user&#39;s email signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplatesApi
     */
    public fetchATeamTemplate(id: string, includeSignature?: boolean, options?: any) {
        return TeamTemplatesApiFp(this.configuration).fetchATeamTemplate(id, includeSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches multiple team template records. The records can be filtered, paged, and sorted according to the respective parameters.  Team templates are templates that are available team-wide. Admins may use team templates to create original content for the entire team, monitor version control to ensure templates are always up to date, and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint. 
     * @summary List team templates
     * @param {Array<string>} [ids] IDs of team templates to fetch. If a record can&#39;t be found, that record won&#39;t be returned and your request will be successful
     * @param {Array<string>} [updatedAt] Equality filters that are applied to the updated_at field. A single filter can be used by itself or combined with other filters to create a range. ---CUSTOM--- {\&quot;type\&quot;:\&quot;object\&quot;,\&quot;keys\&quot;:[{\&quot;name\&quot;:\&quot;gt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;gte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are greater than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lt\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;},{\&quot;name\&quot;:\&quot;lte\&quot;,\&quot;type\&quot;:\&quot;iso8601 string\&quot;,\&quot;description\&quot;:\&quot;Returns all matching records that are less than or equal to the provided iso8601 timestamp. The comparison is done using microsecond precision.\&quot;}]} 
     * @param {string} [search] Filters email templates by title or subject
     * @param {Array<number>} [tagIds] Filters email templates by tags applied to the template by tag ID, not to exceed 100 IDs
     * @param {Array<string>} [tag] Filters team templates by tags applied to the template, not to exceed 100 tags
     * @param {boolean} [includeArchivedTemplates] Filters email templates to include archived templates or not
     * @param {string} [sortBy] Key to sort on, must be one of: created_at, updated_at, last_used_at. Defaults to updated_at
     * @param {string} [sortDirection] Direction to sort in, must be one of: ASC, DESC. Defaults to DESC
     * @param {number} [perPage] How many records to show per page in the range [1, 100]. Defaults to 25
     * @param {number} [page] The current page to fetch results from. Defaults to 1
     * @param {boolean} [includePagingCounts] Whether to include total_pages and total_count in the metadata. Defaults to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamTemplatesApi
     */
    public listTeamTemplates(ids?: Array<string>, updatedAt?: Array<string>, search?: string, tagIds?: Array<number>, tag?: Array<string>, includeArchivedTemplates?: boolean, sortBy?: string, sortDirection?: string, perPage?: number, page?: number, includePagingCounts?: boolean, options?: any) {
        return TeamTemplatesApiFp(this.configuration).listTeamTemplates(ids, updatedAt, search, tagIds, tag, includeArchivedTemplates, sortBy, sortDirection, perPage, page, includePagingCounts, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches a user, by ID only. 
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchAUser.');
            }
            const localVarPath = `/v2/users/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team 
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(guid?: Array<string>, groupId?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/users.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (guid) {
                localVarQueryParameter['guid'] = guid.join(COLLECTION_FORMATS["csv"]);
            }

            if (groupId) {
                localVarQueryParameter['group_id'] = groupId.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches a user, by ID only. 
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).fetchAUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team 
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(guid?: Array<string>, groupId?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(guid, groupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches a user, by ID only. 
         * @summary Fetch a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAUser(id: string, options?: any) {
            return UsersApiFp(configuration).fetchAUser(id, options)(fetch, basePath);
        },
        /**
         * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team 
         * @summary List users
         * @param {Array<string>} [guid] Filters list to only include guids
         * @param {Array<string>} [groupId] Filters users by group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(guid?: Array<string>, groupId?: Array<string>, options?: any) {
            return UsersApiFp(configuration).listUsers(guid, groupId, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Fetches a user, by ID only. 
     * @summary Fetch a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public fetchAUser(id: string, options?: any) {
        return UsersApiFp(this.configuration).fetchAUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * Non Admin: Lists only your user, or all on team depending on group visibility policy Team Admin: Lists users associated with your team 
     * @summary List users
     * @param {Array<string>} [guid] Filters list to only include guids
     * @param {Array<string>} [groupId] Filters users by group_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(guid?: Array<string>, groupId?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).listUsers(guid, groupId, options)(this.fetch, this.basePath);
    }

}

